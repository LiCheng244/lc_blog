(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{323:function(t,a,e){t.exports=e.p+"assets/img/18120301.52ce5833.jpg"},324:function(t,a,e){t.exports=e.p+"assets/img/18120302.c02b8ac9.jpg"},616:function(t,a,e){"use strict";e.r(a);var s=e(6),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",[t._v("关于图形性能优化")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("引言:")]),t._v(" "),s("p",[t._v("当一个产品渐渐成熟，我们便开始重视产品性能的优化。而这其中图形性能的优化在iOS客户端占比较重要的部分。这里我们将介绍"),s("code",[t._v("Core Animation")]),t._v("的运行机制，首先我们不要被它的名字误导了，"),s("code",[t._v("Core Animation")]),t._v("不是只用来做动画的，iOS视图的显示都是通过它来完成的，所以我们想要优化图形性能必须了解"),s("code",[t._v("Core Animation")]),t._v("。下面我们根据苹果WWDC视频讲解来认识"),s("code",[t._v("Core Animation")]),t._v("工作机制，据此分析具体卡顿的原因，如何避免这些问题造成的卡顿，并且结合实际情况说明从哪些方面优化可以事半功倍。")])]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"一-core-animation-工作机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一-core-animation-工作机制"}},[t._v("#")]),t._v(" 一. Core Animation 工作机制")]),t._v(" "),s("p",[s("img",{attrs:{src:e(323),alt:""}})]),t._v(" "),s("p",[t._v("如上图所示，Core Animation在App将图层数据提交到应用外进程"),s("code",[t._v("Render Server")]),t._v("，这是Core Animation的服务端，把数据解码成GPU可执行的指令交给GPU执行。可以看出一个问题渲染服务并不是在App进程内进行的，也就是说渲染部分我们无法进行优化，我们可以优化的点只能在第一个提交事务的阶段。那么这个阶段Core Animation到底做了什么呢？下面我们一起来看看！")]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"二-commit-transaction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二-commit-transaction"}},[t._v("#")]),t._v(" 二. Commit Transaction")]),t._v(" "),s("p",[t._v("提交事务分为四个阶段："),s("code",[t._v("布局")]),t._v("、"),s("code",[t._v("显示")]),t._v("、"),s("code",[t._v("准备")]),t._v("、"),s("code",[t._v("提交")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:e(324),alt:""}})]),t._v(" "),s("h3",{attrs:{id:"_1-布局阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-布局阶段"}},[t._v("#")]),t._v(" 1. 布局阶段")]),t._v(" "),s("p",[t._v("当调用"),s("code",[t._v("addSubview")]),t._v(" 时 "),s("code",[t._v("layer")]),t._v("被加入到"),s("code",[t._v("layer tree")]),t._v(" 中，"),s("code",[t._v("layoutSubviews")]),t._v("被调用，创建"),s("code",[t._v("view")]),t._v("。同时还会进行数据查找，例如app做了本地化，label要显示这些本地化字符串必须从本地化文件中查找到对应语言的布局，这就涉及了I/O操作。所以这里主要是CPU工作，而瓶颈也会是CPU。")]),t._v(" "),s("h3",{attrs:{id:"_2-显示阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-显示阶段"}},[t._v("#")]),t._v(" 2. 显示阶段")]),t._v(" "),s("p",[t._v("在这个阶段如果你重写了"),s("code",[t._v("drawRect")]),t._v("方法，"),s("code",[t._v("Core Graphics")]),t._v("会进行绘制渲染工作。为视图绘制寄宿图即"),s("code",[t._v("contents")]),t._v("。但是"),s("code",[t._v("drawRect")]),t._v("里绘制的内容不会立即显示出来，而是先备换窜起来，等需要的时候被更新到屏幕上。如手动调用"),s("code",[t._v("setNeedsDisplay")]),t._v(" 或 "),s("code",[t._v("sizeThatFits")]),t._v(" 被调用，也可以设置"),s("code",[t._v("cententMode")]),t._v(" 属性值为"),s("code",[t._v("UIViewContentModeRedraw")]),t._v("当每次bounds改变会自动调用 "),s("code",[t._v("setNeedsDisplay")]),t._v("方法。这个阶段主要是CPU和内存的消耗，很多人喜欢用Core Graphics的方法来绘制图形，认为可以提高性能，后面我们会说明这个方法的弊端。")]),t._v(" "),s("h3",{attrs:{id:"_3-准备阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-准备阶段"}},[t._v("#")]),t._v(" 3. 准备阶段")]),t._v(" "),s("p",[t._v("这里的工作主要是图片的解码，因为大部分都是编码后的图片，要读取原始数据必须经过编码过程。并且当我们使用了iOS不支持的图片格式，即不支持硬编码，就需要进行转化工作，也是比较耗时的。所以这里就是GPU消耗，如果进行软解码也要消耗CPU。")]),t._v(" "),s("h3",{attrs:{id:"_4-提交阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-提交阶段"}},[t._v("#")]),t._v(" 4. 提交阶段")]),t._v(" "),s("p",[t._v("最后一个阶段负责打包图层数据并发送到我们上面说的渲染服务中。这个过程是一个递归操作，图层树越复杂越是需要消耗更多资源。像 "),s("code",[t._v("CALaler")]),t._v(" 有很多隐式动画属性也会在这里提交，省去了多次动画属性进程间的交互，提高了性能。")]),t._v(" "),s("p",[t._v("根据上面我们所提到4个阶段，可以根据以下因素来提高我们App的性能。")]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"三-优化因素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三-优化因素"}},[t._v("#")]),t._v(" 三. 优化因素")]),t._v(" "),s("h3",{attrs:{id:"_1-混合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-混合"}},[t._v("#")]),t._v(" 1. 混合")]),t._v(" "),s("p",[t._v("平时我们写代码的时候，往往会给不同的"),s("code",[t._v("CALayer")]),t._v("添加不同的颜色，不同的透明度，我们最后看到是所有这些层"),s("code",[t._v("CALayer")]),t._v("混合出的结果。")]),t._v(" "),s("p",[t._v("那么在iOS中是如何进行混合的？前面我们说明了每个像素都包含了R（红）、G（绿）、B（蓝）和R（透明度），GPU要计算每个像素混合来的RGB值。那么如何计算这些颜色的混合值呢？假设在正常混合模式下，并且是像素对齐的两个CALayer，混合计算公式如下：")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("R "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" S "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" D "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" – Sa "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("苹果的文档中有对每个参数的解释：")]),t._v(" "),s("blockquote",[s("p",[t._v("The blend mode constants introduced in OS X v10.5   represent the Porter-Duff blend modes. The symbols in the   equations for these blend modes are:")]),t._v(" "),s("ul",[s("li",[t._v("R is the premultiplied result")]),t._v(" "),s("li",[t._v("S is the source color, and includes alpha")]),t._v(" "),s("li",[t._v("D is the destination color, and includes alpha")]),t._v(" "),s("li",[t._v("Ra, Sa, and Da are the alpha components of R, S, and D")])])]),t._v(" "),s("p",[t._v("R 就是得到的结果色，S 和 D 是包含透明度的源色和目标色，其实就是预先乘以透明度后的值。Sa就是源色的透明度。iOS为我们提供了多种的"),s("code",[t._v("Blend mode：")])]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* Available in Mac OS X 10.5 & later. R, S, and D are, respectively,\n   premultiplied result, source, and destination colors with alpha; Ra,\n   Sa, and Da are the alpha components of these colors.\n\n   The Porter-Duff "source over" mode is called `kCGBlendModeNormal\':\n     R = S + D*(1 - Sa)\n\n   Note that the Porter-Duff "XOR" mode is only titularly related to the\n   classical bitmap XOR operation (which is unsupported by\n   CoreGraphics). */')]),t._v("\n\nkCGBlendModeClear"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("                  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = 0 */")]),t._v("\nkCGBlendModeCopy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("                   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S */")]),t._v("\nkCGBlendModeSourceIn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("               "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S*Da */")]),t._v("\nkCGBlendModeSourceOut"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("              "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S*(1 - Da) */")]),t._v("\nkCGBlendModeSourceAtop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S*Da + D*(1 - Sa) */")]),t._v("\nkCGBlendModeDestinationOver"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S*(1 - Da) + D */")]),t._v("\nkCGBlendModeDestinationIn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = D*Sa */")]),t._v("\nkCGBlendModeDestinationOut"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("         "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = D*(1 - Sa) */")]),t._v("\nkCGBlendModeDestinationAtop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S*(1 - Da) + D*Sa */")]),t._v("\nkCGBlendModeXOR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = S*(1 - Da) + D*(1 - Sa) */")]),t._v("\nkCGBlendModePlusDarker"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = MAX(0, (1 - D) + (1 - S)) */")]),t._v("\nkCGBlendModePlusLighter             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* R = MIN(1, S + D) */")]),t._v("\n")])])]),s("p",[t._v("似乎计算也不是很复杂，但是这只是一个像素覆盖另一个像素简单的一步计算，而正常情况我们现实的界面会有非常多的层，每一层都会有百万计的像素，这都要GPU去计算，负担是很重的。")]),t._v(" "),s("h3",{attrs:{id:"_2-像素对齐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-像素对齐"}},[t._v("#")]),t._v(" 2. 像素对齐")]),t._v(" "),s("p",[t._v("像素对齐就是视图上像素和屏幕上的物理像素完美对齐。上面我们说混合的时候，假设的情况是多个"),s("code",[t._v("layer")]),t._v("是在每个像素都完全对齐的情况下来进行计算的，如果像素不对齐的情况下，GPU需要进行"),s("code",[t._v("Anti－aliasing")]),t._v("反抗锯齿计算，GPU的负担就会加重。像素对齐的情况下，我们只需要把所有layer上的单个像素进行混合计算即可。")]),t._v(" "),s("p",[t._v("那么什么原因造成像素不对齐？主要有两点：")]),t._v(" "),s("ol",[s("li",[t._v("图片大小和UIImageView大小不符合2倍3倍关系时，如一张12x12二倍，18x18三倍的图，"),s("code",[t._v("UIimageView")]),t._v("的"),s("code",[t._v("size")]),t._v("为6x6才符合像素对齐。")]),t._v(" "),s("li",[t._v("边缘像素不对齐，即起始坐标不是整数，可以使用"),s("code",[t._v("CGRectIntegral()")]),t._v("方法去除小数位。 这两点都有可能造成像素不对齐。如果想获得更好的图形性能，作为开发者要尽可能得避免这两种情况。")])]),t._v(" "),s("h3",{attrs:{id:"_3-不透明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-不透明"}},[t._v("#")]),t._v(" 3. 不透明")]),t._v(" "),s("p",[t._v("上面我们说过一个混合计算的公式："),s("code",[t._v("R = S + D * ( 1 – Sa )")])]),t._v(" "),s("p",[t._v("如果Sa值为1，也就是源色对应的像素不透明。那么得到"),s("code",[t._v("R = S")]),t._v("，这样就只需要拷贝最上层的"),s("code",[t._v("layer")]),t._v("，不需要再进行复杂的计算了。因为下面层的layer全部是可不见的，所以GPU无需进行混合计算了。如何让GPU知道这个图像是不透明的呢？如果使用的是CALayer，那么要把"),s("code",[t._v("opaque")]),t._v("属性设置成YES（默认是NO）。而若只用的是UIView，opaque默认属性是YES。当GPU知道是不透明的时候，只会做简单的拷贝工作，避免了复杂的计算，大大减轻了GPU的工作量。")]),t._v(" "),s("p",[t._v("如果加载一个没有"),s("code",[t._v("alpha")]),t._v("通道的图片，"),s("code",[t._v("opaque")]),t._v("属性会自动设置为YES。但是如果是一个每个像素alpha值都为100%的图片，尽管此图不透明但是Core Animation依然会假定是否存在alpha值不为100%的像素。")]),t._v(" "),s("h3",{attrs:{id:"_4-解码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-解码"}},[t._v("#")]),t._v(" 4. 解码")]),t._v(" "),s("p",[t._v("一般在Core Animation准备阶段，会对图片进行解码操作，即把压缩的图像解码成位图数据。这是一个很消耗CPU的事情。系统是在图片将要渲染到屏幕之前再进行解码，而且默认是在主线程中进行的。所以我们可以将解码放在子线程中进行，下面简单列举一种解码方式：")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("NSString "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("picPath "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSBundle mainBundle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" pathForResource"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"tests"')]),t._v(" ofType"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"png"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nNSData "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("imageData "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSData dataWithContentsOfFile"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("picPath"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//读取未解码图片数据")]),t._v("\n\nCGImageSourceRef imageSourceRef "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageSourceCreateWithData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("__bridge CFTypeRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("imageData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nCGImageRef imageRef "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageSourceCreateImageAtIndex")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageSourceRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CFDictionaryRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("kCGImageSourceShouldCache"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NO"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CFRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageSourceRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nsize_t width "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetWidth")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//获取图片宽度")]),t._v("\nsize_t height "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetHeight")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//获取图片高度")]),t._v("\nCGColorSpaceRef colorSpace "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetColorSpace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nsize_t bitsPerComponent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetBitsPerComponent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//每个颜色组件占的bit数")]),t._v("\nsize_t bitsPerPixel "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetBitsPerPixel")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//每个像素占几bit")]),t._v("\nsize_t bytesPerRow "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetBytesPerRow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//位图数据每行占多少bit")]),t._v("\nCGBitmapInfo bitmapInfo "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetBitmapInfo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nCGDataProviderRef dataProvider "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageGetDataProvider")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CFRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("imageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nCFDataRef dataRef "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGDataProviderCopyData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dataProvider"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//获得解码后数据")]),t._v("\nCGDataProviderRef newProvider "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGDataProviderCreateWithCFData")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dataRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CFRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("dataRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nCGImageRef newImageRef "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CGImageCreate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("width"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" height"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" bitsPerComponent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" bitsPerPixel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" bytesPerRow"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" colorSpace"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" bitmapInfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newProvider"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" false"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" kCGRenderingIntentDefault"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CFRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newProvider"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nUIImage "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("image "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("UIImage imageWithCGImage"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("newImageRef scale"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.0")]),t._v(" orientation"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("UIImageOrientationUp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CFRelease")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newImageRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("另外，在iOS7之后苹果提供了一个属性"),s("code",[t._v("kCGImageSourceShouldCacheImmediately")]),t._v("，在"),s("code",[t._v("CGImageSourceCreateImageAtIndex")]),t._v("方法中，设置"),s("code",[t._v("kCGImageSourceShouldCacheImmediately")]),t._v("为"),s("code",[t._v("kCFBooleanTrue")]),t._v("的话可以立刻开始解压缩，默认为"),s("code",[t._v("kCFBooleanFalse")]),t._v("。当然也像AFNetworking 中使用"),s("code",[t._v("void CGContextDrawImage(CGContextRef __nullable c, CGRect rect, CGImageRef __nullable image)")]),t._v("方法也可以实现解码，具体实现不在此赘述。")]),t._v(" "),s("h3",{attrs:{id:"_5-字节对齐"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-字节对齐"}},[t._v("#")]),t._v(" 5. 字节对齐")]),t._v(" "),s("p",[t._v("我们前面说像素对齐时，简单介绍了字节对齐。那么到底什么是字节对齐？为什么要字节对齐？和我们优化图形性能有什么关系呢？")]),t._v(" "),s("p",[t._v("字节对齐是对基本数据类型的地址做了一些限制，即某种数据类型对象的地址必须是其值的整数倍。例如，处理器从内存中读取一个8个字节的数据，那么数据地址必须是8的整数倍。\n对齐是为了提高读取的性能。因为处理器读取内存中的数据不是一个一个字节读取的，而是一块一块读取的一般叫做"),s("code",[t._v("cache lines")]),t._v("。如果一个不对齐的数据放在了2个数据块中，那么处理器可能要执行两次内存访问。当这种不对齐的数据非常多的时候，就会影响到读取性能了。这样可能会牺牲一些储存空间，但是对提升了内存的性能，对现代计算机来说是更好的选择。")]),t._v(" "),s("p",[t._v("在iOS中，如果这个图像的数据没有字节对齐，那么"),s("code",[t._v("Core Animation")]),t._v("会自动拷贝一份数据做对齐处理。这里我们可以提前做好字节对齐。在方法"),s("code",[t._v("CGBitmapContextCreate(void * __nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef __nullable space, uint32_t bitmapInfo)")]),t._v("中，有一个参数"),s("code",[t._v("bytesPerRow")]),t._v(",意思是指定要使用的位图每行内存的字节数，ARMv7架构的处理器的"),s("code",[t._v("cache lines")]),t._v("是"),s("code",[t._v("32byte")]),t._v("，A9处理器的是"),s("code",[t._v("64byte")]),t._v("，这里我们要使"),s("code",[t._v("bytesPerRow")]),t._v("为64的整数倍。字节对齐，在一般情况下，感觉对性能的影响很小，没必要的情况不要过早优化。")]),t._v(" "),s("h3",{attrs:{id:"_6-离屏渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-离屏渲染"}},[t._v("#")]),t._v(" 6. 离屏渲染")]),t._v(" "),s("p",[t._v("离屏渲染"),s("code",[t._v("（Off-Screen Rendering）")]),t._v("是指GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。离屏渲染是很消耗性能的，因为首先要创建屏幕外缓冲区，还要进行两次上下文环境切换。先切换到屏幕外环境，离屏渲染完成后再切换到当前屏幕，上下文的切换是很高昂的消耗。产生离屏渲染的原因就是这些图层不能直接绘制在屏幕上，必须进行预合成。")]),t._v(" "),s("p",[t._v("产生离屏渲染的情况大概有几种：")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("cornerRadius")]),t._v("和"),s("code",[t._v("masksToBounds")]),t._v("（UIView中是clipToBounds）一起使用的时候，单独使用不会触发离屏渲染。"),s("code",[t._v("cornerRadius")]),t._v("只对背景色起作用,所以有contents的图层需要对其进行裁剪。")]),t._v(" "),s("li",[t._v("为图层设置mask（遮罩）。")]),t._v(" "),s("li",[t._v("layer的"),s("code",[t._v("allowsGroupOpacity")]),t._v("属性为YES且opacity小于1.0，GroupOpacity是指子图层的透明度值不能大于父图层的。")]),t._v(" "),s("li",[t._v("设置了shadow（阴影）。")])]),t._v(" "),s("p",[t._v("上面这几种情况都是GPU的离屏渲染，还有一种特殊的CPU离屏渲染。只要实现"),s("code",[t._v("Core Graphics")]),t._v("绘制API会产生CPU的离屏渲染。因为它也不是直接绘制到屏幕上的，而且先创建屏幕外的缓存。")]),t._v(" "),s("p",[t._v("我们如何解决这几个产生离屏渲染的问题呢?首先，"),s("code",[t._v("GroupOpacity")]),t._v("对性能几乎没有影响，在此就不多说了。圆角是一个无法避免的，网上有很多例子是用"),s("code",[t._v("Core Graphics")]),t._v("绘制来代替系统圆角的，但是"),s("code",[t._v("Core Graphics")]),t._v("是一种软件绘制，利用的是CPU，性能上要差上不少。当然在CPU利用率不是很高的界面是个不错的选择，但是有时候某个界面可能需要CPU去做其他消耗很大的事情，如网络请求。这个时候时候在用Core Graphics绘制大量的圆角图形就有可能出现掉帧。这种情况怎么办呢？最好的就是设计师直接提供圆角图像。还有一种折中的方法就是在混合图层，在原图层上覆盖一个你要的圆角形状的图层，中间需要显示的部分是透明的，覆盖的部分和周围背景一致。")]),t._v(" "),s("p",[t._v("对于"),s("code",[t._v("shadow")]),t._v("，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置"),s("code",[t._v("shadowPath")]),t._v("来优化性能，能大幅提高性能。示例如下：")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("imageView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("layer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("UIColor grayColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("CGColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nimageView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("layer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowOpacity "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nimageView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("layer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowRadius "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nUIBezierPath "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("path "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("UIBezierPath bezierPathWithRect"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("imageView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("frame"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nimageView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("layer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shadowPath "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("CGPath"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("我们还可以通过设置"),s("code",[t._v("shouldRasterize")]),t._v("属性值为YES来强制开启离屏渲染。其实就是"),s("code",[t._v("光栅化（Rasterization）")]),t._v("。既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于"),s("code",[t._v("UITableViewCell")]),t._v("中，cell的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是2.5个屏幕尺寸。在100ms之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。")]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"四-instruments"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四-instruments"}},[t._v("#")]),t._v(" 四. Instruments")]),t._v(" "),s("p",[t._v("上面我们说了这么多性能相关的因素，那么我们怎么进行性能的测试，怎么知道哪些因素影响了图形性能？苹果很人性得为我们提供了一个测试工具Instruments。可以在"),s("code",[t._v("Xcode->Open Develeper Tools->Instruments")]),t._v("中找到，我们看到这里面有很多的测试工具，像大家可能常用的检测内存泄漏的"),s("code",[t._v("Leaks")]),t._v("，在这里我们就讨论下Core Animation这个工具的使用。")]),t._v(" "),s("p",[t._v("Core Animation工具用来监测Core Animation性能。提供可见的FPS值。并且提供几个选项来测量渲染性能，下面我们来说明每个选项的能：")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("Color Blended Layers：")]),t._v("\n这个选项如果勾选，你能看到哪个layer是透明的，GPU正在做混合计算。显示红色的就是透明的，绿色就是不透明的。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Color Hits Green and Misses Red：")]),t._v("\n如果勾选这个选项，且当我们代码中有设置shouldRasterize为YES，那么红色代表没有复用离屏渲染的缓存，绿色则表示复用了缓存。我们当然希望能够复用。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Color Copied Images：")]),t._v("\n按照官方的说法，当图片的颜色格式GPU不支持的时候，即不是32bit的颜色格式，Core Animation会 拷贝一份数据让CPU进行转化。例如从网络上下载了8bit的颜色格式的图片，则需要CPU进行转化，这个区域会显示成蓝色。还有一种情况会触发Core Animation的copy方法，就是字节不对齐的时候。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Color Misaligned Images：")]),t._v("\n勾选此项，如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。像素对齐我们已经在上面有所介绍。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Color Offscreen-Rendered Yellow：")]),t._v("\n用来检测离屏渲染的，如果显示黄色，表示有离屏渲染。当然还要结合Color Hits Green and Misses Red来看，是否复用了缓存。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Color OpenGL Fast Path Blue：")]),t._v("\n这个选项对那些使用OpenGL的图层才有用，像是GLKView或者 CAEAGLLayer，如果不显示蓝色则表示使用了CPU渲染，绘制在了屏幕外，显示蓝色表示正常。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Flash Updated Regions：")]),t._v("\n当对图层重绘的时候回显示黄色，如果频繁发生则会影响性能。可以用增加缓存来增强性能。官方文档Improving Drawing Performance有所说明。")])])]),t._v(" "),s("br"),t._v(" "),s("h2",{attrs:{id:"五-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五-总结"}},[t._v("#")]),t._v(" 五. 总结")]),t._v(" "),s("p",[t._v("结合前面两章内容，我们发现，一个简单的图片显示在屏幕上，要经过很多步骤，并且有许多硬件的参与。最主要的就是CPU和GPU，协调他们之间的工作是高性能得关键。")]),t._v(" "),s("p",[t._v("因为图形的性能和两者都有关系，CPU主要负责软解码、I/O相关、布局的计算等工作，如果使用"),s("code",[t._v("Core Graphics")]),t._v("绘图API那么也会用到CPU。GPU的主要责任就是合成渲染。为了能够得到最好的性能，我们就要找出是哪个限制了性能，CPU过度利用还是GPU负担太大。通过苹果给出的"),s("code",[t._v("Instruments")]),t._v("里面的测试工具，我们在真机上一次次的测试，才能正确的判断出无法保证画面60FPS的原因。必须平衡两者，才能达到最好的性能。")]),t._v(" "),s("p",[t._v("下面我们总结几个优化点：")]),t._v(" "),s("ol",[s("li",[t._v("尽量使用iOS优化处理的图片格式，减少CPU软解码的负担。")]),t._v(" "),s("li",[t._v("能不透明的不要使用透明度，减少混合计算。")]),t._v(" "),s("li",[t._v("不要让图层过于复杂，不然增加了处理图层，打包传送到渲染服务的工作量，GPU渲染负担也会增大。")]),t._v(" "),s("li",[t._v("最好不要使用离屏渲染，必须使用的话最好能够复用缓存，离屏渲染对性能影响是最大的。")]),t._v(" "),s("li",[t._v("布局不要过于复杂，如果必须要复杂的布局，可以提前缓存布局数据。")]),t._v(" "),s("li",[t._v("不要滥用多线程，因为创建和销毁线程不仅增加CPU任务量，而且会消耗内存。")])]),t._v(" "),s("p",[t._v("最后需要说明的就是不要过早和过度得优化，过犹不及。过早优化得不偿失，反而耗时耗力。过度优化有时候适得其反。")]),t._v(" "),s("br")])}),[],!1,null,null,null);a.default=n.exports}}]);