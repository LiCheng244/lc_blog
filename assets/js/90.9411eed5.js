(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{460:function(t,s,a){"use strict";a.r(s);var r=a(6),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",[t._v(" 关于 批处理（合批）")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("前言")]),t._v(" "),a("p",[t._v("众所周知，在电脑硬盘上进行文件移动操作，对于单独一个1G的文件 和 1024个1M的文件，前者通常会比后者更快完成。OpenGL渲染批处理的概念，可以考虑成与之类似的一种处理。")])]),t._v(" "),a("h2",{attrs:{id:"一-什么是批处理？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-什么是批处理？"}},[t._v("#")]),t._v(" 一. 什么是批处理？")]),t._v(" "),a("p",[t._v("设想下面两种情况：")]),t._v(" "),a("h3",{attrs:{id:"_1-一帧中，执行1000次以下步骤："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-一帧中，执行1000次以下步骤："}},[t._v("#")]),t._v(" 1.一帧中，执行1000次以下步骤：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("创建一个四边形的6个顶点（两个三角形），索引，颜色，并绑定；")])]),t._v(" "),a("li",[t._v("绑定纹理；")]),t._v(" "),a("li",[t._v("使用shader；")]),t._v(" "),a("li",[t._v("glDrawElements()；")])]),t._v(" "),a("h3",{attrs:{id:"_2-一帧中，执行1次以下步骤："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-一帧中，执行1次以下步骤："}},[t._v("#")]),t._v(" 2.一帧中，执行1次以下步骤：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("创建一个1000个四边形的6000个顶点，索引，颜色，并绑定；")])]),t._v(" "),a("li",[t._v("绑定纹理；")]),t._v(" "),a("li",[t._v("使用shader；")]),t._v(" "),a("li",[t._v("glDrawElements()；")])]),t._v(" "),a("p",[a("code",[t._v("两种做法最终都在一帧中完成了1000个四边形，6000个顶点的绘制。但B方法的2，3，4步仅仅只执行了一次，而A的2，3，4各执行了1000次。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("其实方法1，就是我们所谓的“批处理”   ——  "),a("strong",[t._v("把多个顶点放在“同一批”去绘制。")])])]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"二-图集为什么能批处理？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-图集为什么能批处理？"}},[t._v("#")]),t._v(" 二. 图集为什么能批处理？")]),t._v(" "),a("p",[t._v("通过上面的分析，我们知道，要让多个绘制合并到一个Drawcall, 要满足以下几个前提条件：")]),t._v(" "),a("ol",[a("li",[t._v("多个顶点同时绑定；")]),t._v(" "),a("li",[t._v("这批顶点使用同一个（或同一组）纹理数据；")]),t._v(" "),a("li",[t._v("这批顶点使用相同的shader及其他相同的绘制参数。")])]),t._v(" "),a("p",[t._v("考虑条件2，我们要"),a("code",[t._v("保证绘制列表里的元素都使用同一份纹理数据")]),t._v(" ，而图集就是让我们达到这一点的手段。")]),t._v(" "),a("h3",{attrs:{id:"那怎么让不同内容的sprite使用图集上的不同部分呢？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#那怎么让不同内容的sprite使用图集上的不同部分呢？"}},[t._v("#")]),t._v(" 那怎么让不同内容的Sprite使用图集上的不同部分呢？")]),t._v(" "),a("p",[t._v("我们准备提交给GL的顶点数据中，不仅包括每个顶点的位置，索引，颜色，同时也会将一个“UV坐标”提交给GL，它指某个顶点在纹理中对应的像素位置。引擎会在shader中根据UV坐标，来确定渲染出来的像素对应图集中的哪一部分。")]),t._v(" "),a("p",[t._v("比如cocosCreator的默认shader，builtin-2d-sprite.effect：")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    vec4 o "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vec4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n    "),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[t._v("USE_TEXTURE")])]),t._v("\n    o "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("texture"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v_uv0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//根据UV坐标确定像素值")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token expression"}},[t._v("CC_USE_ALPHA_ATLAS_TEXTURE")])]),t._v("\n      o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("texture2D")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("texture"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" v_uv0 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("vec2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n \n    o "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v(" v_color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ALPHA_TEST")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n    gl_FragColor "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" o"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("因为UV坐标是和其他顶点信息一起提交的，它只在每次绑定时被改变（被赋值），所以虽然渲染不同Sprite使用了不同的UV值，但不会造成drawCalls的增加。 合图就是用这种方式实现了不同内容的多个Sprite合批。")]),t._v(" "),a("p",[t._v("由此可知，我们对顶点分别设置不同的颜色，也不会造成drawCalls增加。比如在合批的前提下，进行 "),a("code",[t._v('nodeA.color = cc.Color("#ff0000")')]),t._v("这样的操作是不会导致drawCalls增加的。因为colorCreator引擎将色值作为顶点数据一起绑定。")]),t._v(" "),a("h2",{attrs:{id:"三-什么情况会打断合批？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-什么情况会打断合批？"}},[t._v("#")]),t._v(" 三. 什么情况会打断合批？")]),t._v(" "),a("p",[t._v("我们已经知道如何利用图集实现批处理，但仅仅采用图集并不能保证多个视图元素drawCalls次数为1。OPENGL的绘制有几个步骤，但凡其中任一步骤发生变化，都会“打断合批”，导致drawCalls次数增加。")]),t._v(" "),a("h3",{attrs:{id:"下面是一些常见的必定会打断合批的应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下面是一些常见的必定会打断合批的应用场景"}},[t._v("#")]),t._v(" 下面是一些常见的必定会打断合批的应用场景:")]),t._v(" "),a("ul",[a("li",[t._v("Sprite 使用了不同的贴图文件（散图）；")]),t._v(" "),a("li",[t._v("用了 cc.Mask 遮罩（使用了不同的模板测试策略）；")]),t._v(" "),a("li",[t._v("多个 Sprite 运用了不同的混合模式 cc.Blend ；")]),t._v(" "),a("li",[t._v("多个 Sprite 运用了不同的 shader ；")]),t._v(" "),a("li",[t._v("多个 Sprite 运用了相同的 shader, 但使用了不同的 uniform 值；")]),t._v(" "),a("li",[t._v("渲染队列中有文本框“插队”，而这个文本框中的字符贴图并没有使用图集中的素材；")])]),t._v(" "),a("h3",{attrs:{id:"下面的这些改变不会打断合批（在已经保证合批的前提下）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#下面的这些改变不会打断合批（在已经保证合批的前提下）"}},[t._v("#")]),t._v(" 下面的这些改变不会打断合批（在已经保证合批的前提下）:")]),t._v(" "),a("ul",[a("li",[t._v("node.color, node.opacity的变化；")]),t._v(" "),a("li",[t._v("纹理拉伸策略的不同，SIMLE, SLICED, TILED；")]),t._v(" "),a("li",[t._v("Sprite SizeMode的不同，CUSTOM，TRIMMED；")]),t._v(" "),a("li",[t._v("顶点动画（简单的比如位移，scale,skew,rotate, 或者一些复杂的顶点动画效果，比如Spine的FFD(挤压，弯曲，变形)) ；")])]),t._v(" "),a("br")])}),[],!1,null,null,null);s.default=e.exports}}]);