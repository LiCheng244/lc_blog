(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{373:function(t,s,a){t.exports=a.p+"assets/img/18122900.427ceb8a.png"},653:function(t,s,a){"use strict";a.r(s);var n=a(6),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("hr"),t._v(" "),n("h4",{attrs:{id:"_1-猜想runloop内部是如何实现的？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-猜想runloop内部是如何实现的？"}},[t._v("#")]),t._v(" 1. 猜想runloop内部是如何实现的？")]),t._v(" "),n("p",[t._v("从字面意思看：运行循环、跑圈；")]),t._v(" "),n("p",[n("strong",[t._v("本质：")]),t._v("\n内部就是"),n("code",[t._v("do-while")]),t._v("循环，在这个循环内部不断地处理各种事件(任务)，比如："),n("code",[t._v("Source")]),t._v("、"),n("code",[t._v("Timer")]),t._v("、"),n("code",[t._v("Observer")]),t._v("；")]),t._v(" "),n("p",[t._v("每条线程都有唯一一个RunLoop对象与之对应，主线程的RunLoop默认已经启动，子线程的RunLoop需要手动启动；\n每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode，如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入，这样做主要是为了隔离不同Mode中的Source、Timer、Observer，让其互不影响；")]),t._v(" "),n("p",[t._v("附上RunLoop的运行图 :\n"),n("img",{attrs:{src:a(373),alt:""}})]),t._v(" "),n("hr"),t._v(" "),n("h4",{attrs:{id:"_2-苹果是如何实现autoreleasepool的？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-苹果是如何实现autoreleasepool的？"}},[t._v("#")]),t._v(" 2. 苹果是如何实现autoreleasepool的？")]),t._v(" "),n("p",[n("code",[t._v("autoreleasepool")]),t._v("以一个队列数组的形式实现,主要通过下列三个函数完成.")]),t._v(" "),n("div",{staticClass:"language-objectivec extra-class"},[n("pre",{pre:!0,attrs:{class:"language-objectivec"}},[n("code",[t._v("objc_autoreleasepoolPush\nobjc_autoreleasepoolPop\nobjc_aurorelease\n")])])]),n("p",[t._v("看函数名就可以知道，对autorelease分别执行push，和pop操作。销毁对象时执行release操作")]),t._v(" "),n("hr"),t._v(" "),n("h4",{attrs:{id:"_3-gcd的队列（dispatch-queue-t）分哪两种类型？背后的线程模型是什么样的？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-gcd的队列（dispatch-queue-t）分哪两种类型？背后的线程模型是什么样的？"}},[t._v("#")]),t._v(" 3. GCD的队列（dispatch_queue_t）分哪两种类型？背后的线程模型是什么样的？")]),t._v(" "),n("p",[t._v("串行队列、并行队列")]),t._v(" "),n("p",[n("code",[t._v("dispatch_global_queue();")]),t._v("是全局并发队列\n"),n("code",[t._v("dispatch_main_queue();")]),t._v("是一种特殊串行队列")]),t._v(" "),n("p",[t._v("背后的线程模型：\n自定义队列"),n("code",[t._v("dispatch_queue_t queue;")]),t._v("可以自定义是并行："),n("code",[t._v("DISPATCH_QUEUE_CONCURRENT")]),t._v(" 或者 串行 "),n("code",[t._v("DISPATCH_QUEUE_SERIAL")])]),t._v(" "),n("hr"),t._v(" "),n("h4",{attrs:{id:"_4-如何用gcd同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何用gcd同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）"}},[t._v("#")]),t._v(" 4. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）")]),t._v(" "),n("p",[t._v("必须是并发队列才起作用")]),t._v(" "),n("p",[n("strong",[t._v("需求分析:")]),t._v("\n首先，分别异步执行2个耗时的操作, 其次，等2个异步操作都执行完毕后，再回到主线程执行一些操作")]),t._v(" "),n("p",[n("strong",[t._v("使用队列组实现上面的需求:")])]),t._v(" "),n("div",{staticClass:"language-objectivec extra-class"},[n("pre",{pre:!0,attrs:{class:"language-objectivec"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建队列组")]),t._v("\ndispatch_group_t group "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_group_create")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取全局并发队列")]),t._v("\ndispatch_queue_t queue "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_get_global_queue")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DISPATCH_QUEUE_PRIORITY_DEFAULT"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 往队列组中添加耗时操作")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_group_async")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("group"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" queue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行耗时的异步操作1")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 往队列组中添加耗时操作")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_group_async")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("group"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" queue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行耗时的异步操作2")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当并发队列组中的任务执行完毕后才会执行这里的代码")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_group_notify")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("group"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" queue"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果这里还有基于上面两个任务的结果继续执行一些代码，建议还是放到子线程中，等代码执行完毕后在回到主线程")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 回到主线程")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_async")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("group"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("dispatch_get_main_queue")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行相关代码...")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("hr"),t._v(" "),n("h4",{attrs:{id:"_5-以-scheduledtimerwithtimeinterval-的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-以-scheduledtimerwithtimeinterval-的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"}},[t._v("#")]),t._v(" 5. 以+scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？")]),t._v(" "),n("p",[n("strong",[t._v("这里强调一点：")]),t._v("\n在主线程中以"),n("code",[t._v("+scheduledTimerWithTimeInterval...")]),t._v("的方式触发的timer默认是运行在"),n("code",[t._v("NSDefaultRunLoopMode")]),t._v("模式下的，当滑动页面上的列表时，进入了"),n("code",[t._v("UITrackingRunLoopMode")]),t._v("模式，这时候timer就会停止")]),t._v(" "),n("p",[t._v("可以修改timer的运行模式为"),n("code",[t._v("NSRunLoopCommonModes")]),t._v("，这样定时器就可以一直运行了")]),t._v(" "),n("p",[n("strong",[t._v("补充：")])]),t._v(" "),n("ul",[n("li",[t._v("在子线程中通过"),n("code",[t._v("scheduledTimerWithTimeInterval:...")]),t._v("方法来构建NSTimer")]),t._v(" "),n("li",[t._v("方法内部已经创建"),n("code",[t._v("NSTimer")]),t._v("对象，并加入到RunLoop中，运行模式为"),n("code",[t._v("NSDefaultRunLoopMode")])]),t._v(" "),n("li",[t._v("由于Mode有timer对象，所以RunLoop就开始监听定时器事件了，从而开始进入运行循环")]),t._v(" "),n("li",[t._v("这个方法仅仅是创建RunLoop对象，并不会主动启动RunLoop，需要再调用run方法来启动")]),t._v(" "),n("li",[t._v("如果在主线程中通过"),n("code",[t._v("scheduledTimerWithTimeInterval:...")]),t._v("法来构建NSTimer，就不需要主动启动RunLoop对象，因为主线程的RunLoop对象在程序运行起来就已经被启动了")])]),t._v(" "),n("div",{staticClass:"language-objectivec extra-class"},[n("pre",{pre:!0,attrs:{class:"language-objectivec"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// userInfo参数：用来给NSTimer的userInfo属性赋值，userInfo是只读的，只能在构建NSTimer对象时赋值")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSTimer scheduledTimerWithTimeInterval"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.0")]),t._v(" target"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" selector"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@selector")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("run"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" userInfo"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"ya了个hoo"')]),t._v(" repeats"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("YES"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// scheduledTimer...方法创建出来NSTimer虽然已经指定了默认模式，但是【允许你修改模式】")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSRunLoop currentRunLoop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" addTimer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("timer forMode"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("NSRunLoopCommonModes"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 【仅在子线程】需要手动启动RunLoop对象，进入运行循环")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSRunLoop currentRunLoop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" run"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("hr")])}),[],!1,null,null,null);s.default=e.exports}}]);