(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{635:function(t,_,a){"use strict";a.r(_);var v=a(6),e=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",[t._v("OC 基础面试题 I")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("引言：")])]),t._v(" "),a("h2",{attrs:{id:"_1-define-和-const-有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-define-和-const-有什么区别？"}},[t._v("#")]),t._v(" 1. define 和 const 有什么区别？")]),t._v(" "),a("p",[a("code",[t._v("#define")]),t._v(" 定义的宏，程序在预处理阶段将用#define 定义的宏的内容进行了替换。因此程序运行时，在常量表中并没有使用"),a("code",[t._v("#define")]),t._v(" 定义的宏，不会分配内存，在编译时不会检查数据类型， 出错的概率会大一些。定义表达式时要注意边缘效应。")]),t._v(" "),a("p",[a("code",[t._v("const")]),t._v("定义的常量，在程序运行时是存放在常量表中，系统会为其分配内存，并且会检查数据类型。\n"),a("code",[t._v("define")]),t._v("在预处理阶段进行替换，const常量在编译阶段使用")]),t._v(" "),a("p",[t._v("宏不做类型检查，仅仅进行替换，const常量有数据类型，会执行类型检查; define不能调试，const常量可以调试; define定义的常量在替换后运行过程中会不断地占用内存，而const定义的常量存储在数据段只有一份copy，效率更高 ;  define可以定义一些简单的函数，const不可以。")]),t._v(" "),a("h2",{attrs:{id:"_2-const-定义常量的方式？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-const-定义常量的方式？"}},[t._v("#")]),t._v(" 2. const 定义常量的方式？")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("const int a;")]),t._v(" a 是指向整数的指针（整数不可变，指针可以变）。")]),t._v(" "),a("li",[a("code",[t._v("int * const a;")]),t._v(" a 是指向整数的指针（指针指向的整数是可变的，但是指针是不可变的）。")]),t._v(" "),a("li",[a("code",[t._v("int const *const a;")]),t._v(" a是指向常整数型的指针（指针指向的整数和指针本身都是不可改变的）。")])]),t._v(" "),a("h2",{attrs:{id:"_3-数组和指针的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-数组和指针的区别？"}},[t._v("#")]),t._v(" 3. 数组和指针的区别？")]),t._v(" "),a("ol",[a("li",[t._v("数组可以申请在栈区和静态数据区；指针可以指向任意类型的内存块。")]),t._v(" "),a("li",[t._v("数组名表示的是数组首地址，是常量指针，不可改变；普通指针的值可以改变。")]),t._v(" "),a("li",[t._v("用字符串初始化字符数组是将字符串的内容拷贝到字符数组中；用字符串初始化字符指针，是将字符串的首地址赋值给指针，也就是指针指向了该字符串。")])]),t._v(" "),a("h2",{attrs:{id:"_4-方法和选择器有什么不同？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-方法和选择器有什么不同？"}},[t._v("#")]),t._v(" 4. 方法和选择器有什么不同？")]),t._v(" "),a("ol",[a("li",[t._v("选择器（"),a("code",[t._v("selector")]),t._v("）：是一个方法的名字。")]),t._v(" "),a("li",[t._v("方法：是一个组合体， 包含了名字和实现。")])]),t._v(" "),a("h2",{attrs:{id:"_5-malloc-和-new-的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-malloc-和-new-的区别？"}},[t._v("#")]),t._v(" 5. malloc 和 new 的区别？")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("new")]),t._v(" 是C++的操作符，"),a("code",[t._v("malloc")]),t._v(" 是 C 中的函数。")]),t._v(" "),a("li",[t._v("new 不只分配内存空间，还会调用类的构造函数；malloc 只会分配内存空间，不会进行初始化类成员的工作。")]),t._v(" "),a("li",[t._v("内存泄露时，都可以检测出来；但是 new 会指出哪个文件的哪一行，malloc 则不会。")]),t._v(" "),a("li",[t._v("new 可以认为是 malloc+构造函数的执行。")]),t._v(" "),a("li",[t._v("new 出来的指针是直接带类型信息的。")])]),t._v(" "),a("h2",{attrs:{id:"_6-简述一下-oc-中的反射机制？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-简述一下-oc-中的反射机制？"}},[t._v("#")]),t._v(" 6. 简述一下 OC 中的反射机制？")]),t._v(" "),a("p",[a("strong",[t._v("class 反射:")])]),t._v(" "),a("p",[t._v("通过类名的字符串实例化对象:")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[t._v("Class class "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSClassFromString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"View"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nView "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("view "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("class alloc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" init"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("将类名转换成字符串:")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[t._v("Class class "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("View class"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nNSString "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("className "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSStringFromClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("class"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("strong",[t._v("SEL 反射:")])]),t._v(" "),a("p",[t._v("通过方法名的字符串实例化：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[t._v("SEL selector "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSSelectorFromClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"setName"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("stu performSelector"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("selector withObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"Mike"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("将方法变成字符串：")]),t._v(" "),a("div",{staticClass:"language-objectivec extra-class"},[a("pre",{pre:!0,attrs:{class:"language-objectivec"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSStringFomrSelector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@selector")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("setName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h2",{attrs:{id:"_7-什么是-sel？如何使用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-什么是-sel？如何使用？"}},[t._v("#")]),t._v(" 7. 什么是 SEL？如何使用？")]),t._v(" "),a("p",[t._v("SEL 就是对方法的一种包装。包装的 SEL 类型数据对应的是相应方法的地址，找到方法地址就可以调用方法。\n在内存中每个类方法都存在类对象中，每个方法都有一个与之对应的 SEL 类型的数据，根据一个 SEL 数据就可以找到对应方法的地址，进而调用方法。")]),t._v(" "),a("p",[t._v("**包装方法： **")]),t._v(" "),a("p",[a("code",[t._v("SEL s1 = @selector(test);")])]),t._v(" "),a("p",[a("strong",[t._v("调用方法：")])]),t._v(" "),a("p",[t._v("直接通过方法名调用： "),a("code",[t._v("[person text]")]),t._v("；")]),t._v(" "),a("p",[t._v("间接的通过 SEL 数据来调用："),a("code",[t._v("SEL aaa=@selector(text); [person performSelector:aaa];")])]),t._v(" "),a("h2",{attrs:{id:"_8-ns-cf-cg-ca-ui这些前缀分别代表什么含义？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-ns-cf-cg-ca-ui这些前缀分别代表什么含义？"}},[t._v("#")]),t._v(" 8. NS/CF/CG/CA/UI这些前缀分别代表什么含义？")]),t._v(" "),a("ol",[a("li",[t._v("NS： 函数归属于 "),a("code",[t._v("cocoa Fundation")]),t._v(" 框架；")]),t._v(" "),a("li",[t._v("CF： 函数归属于 "),a("code",[t._v("core Fundation")]),t._v(" 框架；")]),t._v(" "),a("li",[t._v("CG： 函数归属于 "),a("code",[t._v("CoreGraphics.frameworks")]),t._v(" 框架；")]),t._v(" "),a("li",[t._v("CA： 函数归属于 "),a("code",[t._v("CoreAnimation.frameworks")]),t._v(" 框架；")]),t._v(" "),a("li",[t._v("UI： 函数归属于 "),a("code",[t._v("UIKit")]),t._v(" 框架。")])]),t._v(" "),a("h2",{attrs:{id:"_9-面向对象有哪些特征？谈谈自己的理解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-面向对象有哪些特征？谈谈自己的理解？"}},[t._v("#")]),t._v(" 9. 面向对象有哪些特征？谈谈自己的理解？")]),t._v(" "),a("p",[a("strong",[t._v("继承：")])]),t._v(" "),a("ol",[a("li",[t._v("继承是从已有类得到继承信息创建新类的过程。")]),t._v(" "),a("li",[t._v("提供继承信息的类被称为父类；得到继承信息的类被称为子类。")]),t._v(" "),a("li",[t._v("继承让系统有一定的延续性，也是封装程序的重要手段。")])]),t._v(" "),a("p",[a("strong",[t._v("封装：")])]),t._v(" "),a("ol",[a("li",[t._v("就是隐藏一切能够隐藏的东西，向外界提供最简单的调用接口。")]),t._v(" "),a("li",[t._v("把数据和数据操作的方法绑定起来，外界对数据的访问只能通过定义好的接口来访问。")]),t._v(" "),a("li",[t._v("日常开发中定义方法，就是封装的一种体现。")])]),t._v(" "),a("p",[a("strong",[t._v("多态：")])]),t._v(" "),a("ol",[a("li",[t._v("允许不同子类型的对象对统一消息作出不同的响应。")]),t._v(" "),a("li",[t._v("用同样的对象调用相同的方法，却实现了不同的事情。")]),t._v(" "),a("li",[t._v("编译时多态： 方法的重载（前绑定）。")]),t._v(" "),a("li",[t._v("运行时多态：方法的重写（后绑定）。")])]),t._v(" "),a("p",[a("strong",[t._v("方法重写：")])]),t._v(" "),a("ol",[a("li",[t._v("子类继承父类并重写父类已有或抽象的方法。")])]),t._v(" "),a("p",[a("strong",[t._v("对象造型：")])]),t._v(" "),a("ol",[a("li",[t._v("举例 生物类都有一个相同的方法 set。人属于生物类，狗也属于生物类，都继承自生物类，分别实现了各自的 eat 方法，但是调用时只需要调用各自的 eat，就能都响应了 eat 的x消息。")])]),t._v(" "),a("p",[a("strong",[t._v("抽象：")])]),t._v(" "),a("ol",[a("li",[t._v("将一类对象的共同特性总结出来构造类的过程。")]),t._v(" "),a("li",[t._v("包括数据抽象（属性）和行为抽象（方法）。")]),t._v(" "),a("li",[t._v("抽象只关注对象有哪些属性和行为， 不关心行为的细节是什么。")])]),t._v(" "),a("h2",{attrs:{id:"_10-为什么说-oc-是运行时语言？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-为什么说-oc-是运行时语言？"}},[t._v("#")]),t._v(" 10. 为什么说 OC 是运行时语言？")]),t._v(" "),a("ol",[a("li",[t._v("主要是将数据类型的确认由编译时，推迟到了运行时。")]),t._v(" "),a("li",[t._v("运行时机制，使我们直到运行时才去决定一个对象的类别，以及对象调用的方法。")])]),t._v(" "),a("h2",{attrs:{id:"_11-readwrite-readonly-assign-weak-retain-strong-copy-nonatomic-属性的作用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-readwrite-readonly-assign-weak-retain-strong-copy-nonatomic-属性的作用？"}},[t._v("#")]),t._v(" 11. readwrite, readonly, assign, weak, retain, strong, copy, nonatomic 属性的作用？")]),t._v(" "),a("p",[a("code",[t._v("readwrite：")])]),t._v(" "),a("p",[t._v("可读可写特性。需要生成 getter 和 setter 方法时使用。")]),t._v(" "),a("p",[a("code",[t._v("readonly：")])]),t._v(" "),a("p",[t._v("只读特性。 只会生成 getter 方法，不会生成setter方法；不希望属性在类外被改变。")]),t._v(" "),a("p",[a("code",[t._v("assgin：")])]),t._v(" "),a("p",[t._v("是 mrc/arc中， 赋值属性，setter 方法将传入的值设置给实例变量；在设置数值的时候，不会做任何附加操作\narc 中，通常用来保存基本数据类型；mrc 中，如果不需要引用，就是用 assgin。 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时；")]),t._v(" "),a("p",[a("code",[t._v("weak：")])]),t._v(" "),a("p",[t._v("在 arc 中，用来保存不需要强引用的对象. weak 修饰的属性，如果没有其他对象对其强引用，就会被立即释放。")]),t._v(" "),a("p",[a("code",[t._v("retain：")])]),t._v(" "),a("p",[t._v("mrc中的，持有属性，setter 方法传入的值先保留，再赋值，传入的值的引用计数"),a("code",[t._v("retainCount")]),t._v("会 + 1。")]),t._v(" "),a("p",[a("code",[t._v("strong：")])]),t._v(" "),a("p",[t._v("arc 中的，与 retain 等效。")]),t._v(" "),a("p",[a("code",[t._v("copy：")])]),t._v(" "),a("p",[t._v("赋值特性，setter 方法将传入的值完全复制一份；需要完全一份新的变量时使用。")]),t._v(" "),a("p",[a("code",[t._v("nonatominc：")])]),t._v(" "),a("p",[t._v("非原子性，决定编译器生成的getter，setter 是否是原子操作。在自己管理的内存环境中，访问器只是简单的返回这个值。")]),t._v(" "),a("p",[a("code",[t._v("natominc：")])]),t._v(" "),a("p",[t._v("原子性；多线程安全，防止读写未完成时被另一个线程读写，一般使用 nonatomic。")]),t._v(" "),a("p",[a("strong",[t._v("weak 和 assgin 的区别：")])]),t._v(" "),a("ol",[a("li",[t._v("assgin 指向的对象如果被释放，地址不会有任何变化")]),t._v(" "),a("li",[t._v("weak 指向的对象如果被释放，地址会立即变化为 nil（指向0的空对象）")]),t._v(" "),a("li",[t._v("assgin 的效率高，风险大（野指针）")])]),t._v(" "),a("p",[a("strong",[t._v("如何一个值，在属性中，本质上保存的都是一个“数字”:")])]),t._v(" "),a("ol",[a("li",[t._v("如果是对象， 保存的是堆中的地址")]),t._v(" "),a("li",[t._v("如果是基本数据类型，保存的是基本数据类型的数值")])]),t._v(" "),a("h2",{attrs:{id:"_12-懒加载？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-懒加载？"}},[t._v("#")]),t._v(" 12. 懒加载？")]),t._v(" "),a("p",[t._v("在用到的时候才初始化。也可以理解为延时加载。")]),t._v(" "),a("p",[t._v("最好的例子就是 tableView中图片的加载显示，一个延时加载，避免内存过高；一个异步加载，避免线程堵塞提高用户体验。")]),t._v(" "),a("h2",{attrs:{id:"_13-oc-有多继承么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-oc-有多继承么？"}},[t._v("#")]),t._v(" 13. OC 有多继承么？")]),t._v(" "),a("p",[t._v("多继承是指一个子类继承多个父类，继承多个父类的特性。"),a("code",[t._v("OC 中没有多继承，只支持单继承。可以通过类别和协议来实现。")])]),t._v(" "),a("p",[t._v("**协议：**可以实现多个接口，通过实现多个接口来完成多继承。\n**类别：**一般使用分类，去重写类的方法，仅对当前分类有效，不会影响其他分类和原有类。")]),t._v(" "),a("h2",{attrs:{id:"_14-oc有私有方法，私有变量么？如果没有如何代替？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-oc有私有方法，私有变量么？如果没有如何代替？"}},[t._v("#")]),t._v(" 14. OC有私有方法，私有变量么？如果没有如何代替？")]),t._v(" "),a("p",[t._v("没有私有方法， OC中的方法只有两个，实例方法（-），类方法（+）。可以通过把方法的声明和定义都放到.m 文件中来实现表面上的私有方法。")]),t._v(" "),a("p",[t._v("OC 中有私有变量，可以通过@private 来修饰，也可以把声明放在.m 文件中。\nOC 中所有的实例变量都是默认私有的，实例方法默认都是共有的。")]),t._v(" "),a("h2",{attrs:{id:"_15-描述类别（category）和延展（extensions）的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-描述类别（category）和延展（extensions）的区别？"}},[t._v("#")]),t._v(" 15. 描述类别（Category）和延展（extensions）的区别？")]),t._v(" "),a("p",[a("strong",[t._v("类别：")])]),t._v(" "),a("p",[t._v("在没有原来类的.m 文件的基础上，来添加实例方法。")]),t._v(" "),a("p",[a("strong",[t._v("延展：")])]),t._v(" "),a("p",[t._v("特殊形式的类别，在.m 文件中声明和实现延展的作用，给某个类添加私有方法或私有变量。")]),t._v(" "),a("p",[a("strong",[t._v("区别：")])]),t._v(" "),a("ol",[a("li",[t._v("延展可以添加属性，并且它的方法是必须要实现的。可以认为是一个私有的类目。")]),t._v(" "),a("li",[t._v("类别可以在不知道不改变原来代码的情况下，来添加新的方法，但是不能修改删除原来的方法。")]),t._v(" "),a("li",[t._v("类别优先级更高。如果类别中和原有类中的类名冲突会优先调用类别中的方法。")]),t._v(" "),a("li",[t._v("Category 只能添加方法，不能添加成员变量：原因是 如果可以添加成员变量，添加的成员变量没法初始化。")])]),t._v(" "),a("h2",{attrs:{id:"_16-include-和-import-的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-include-和-import-的区别？"}},[t._v("#")]),t._v(" 16. include 和 #import 的区别？")]),t._v(" "),a("p",[t._v("import 是 OC 对 include 的改进版本，确保引用的文件只会被引用一次，bu会陷入递归包含的问题。")]),t._v(" "),a("h2",{attrs:{id:"_17-import、-include-和-class-的区别？＃import-跟-import-又什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-import、-include-和-class-的区别？＃import-跟-import-又什么区别？"}},[t._v("#")]),t._v(" 17. #import、#include 和 @class 的区别？＃import<> 跟 #import””又什么区别？")]),t._v(" "),a("p",[a("code",[t._v("#import")]),t._v("是Objective-C导入头文件的关键字， 会引入该头文件中的全部信息，包括实例变量和方法等等;"),a("br"),t._v(" "),a("code",[t._v("#include")]),t._v("是C/C++导入头文件的关键字;\n"),a("code",[t._v("@class")]),t._v("只是告诉编译器，声明的是类的名称，至于这些类是如何定义的暂时不考虑，当执行时，才去查看类的实现文件，可以解决头文件的相互包含；这种写法叫做类的前置声明。")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("#import")]),t._v("头文件会自动只导入一次，不会重复导入，相当于"),a("code",[t._v("#include")]),t._v("和"),a("code",[t._v("#pragma once")]),t._v("；")]),t._v(" "),a("p",[t._v("一般在.h文件中使用 @calss，不需要知道引入类中的内部实现。\n一般在.m 文件中会用到引入类的实例变量或方法，所以使用 #import 引入。")]),t._v(" "),a("p",[t._v("效率方面，import 效率低，任意一个类发生改变，所有引用的类都需要重新编译；@class 则不会。\n如果有循环依赖关系，A->B, B->A这样的相互依赖的关系，如果使用的是 import 来包含，会出现编译错误；如果使用@class 在两个类头文件中相互声明，编译不会出现错误。")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("#import<>")]),t._v("用来包含系统的头文件，"),a("code",[t._v('#import ""')]),t._v("来包含用户自定义头文件。")])]),t._v(" "),a("h2",{attrs:{id:"_18-深拷贝（深赋值）和浅拷贝的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-深拷贝（深赋值）和浅拷贝的区别？"}},[t._v("#")]),t._v(" 18. 深拷贝（深赋值）和浅拷贝的区别？")]),t._v(" "),a("p",[a("code",[t._v("浅拷贝（copy）")]),t._v("：只复制对象的指针，而不复制引用对象的本身。\n"),a("code",[t._v("深拷贝（mutableCopy）")]),t._v("：复制引用对象本身。内存中会存在两个本身独立的对象，当修改 A 时，A _copy 不会发生改变。")]),t._v(" "),a("h2",{attrs:{id:"_19-类变量中-protected、-private、-public、-package声明有什么含义？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-类变量中-protected、-private、-public、-package声明有什么含义？"}},[t._v("#")]),t._v(" 19. 类变量中@protected、@private、@public、@package声明有什么含义？")]),t._v(" "),a("p",[t._v("表示变量的不同的作用域。")]),t._v(" "),a("p",[a("code",[t._v("@proteected:")]),t._v(" 受保护，在该类和子类中可以访问，默认的；\n"),a("code",[t._v("@private：")]),t._v("私有的，只能在该类中访问；\n"),a("code",[t._v("@public：")]),t._v("共有的，在任何地方都能访问；\n"),a("code",[t._v("@package：")]),t._v(" 本包内可以访问，不能跨包访问。")]),t._v(" "),a("h2",{attrs:{id:"_20-oc-的消息机制？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-oc-的消息机制？"}},[t._v("#")]),t._v(" 20. OC 的消息机制？")]),t._v(" "),a("p",[t._v("OC 的函数调用被称为消息发送，属于动态调用过程。\n在编译期间并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到函数调用。\nOC 在编译阶段可以调用任何函数，即使函数并未实现，只要声明了就不会报错。")]),t._v(" "),a("h2",{attrs:{id:"_21-常见的-oc-数据类型有哪些？与-c-有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-常见的-oc-数据类型有哪些？与-c-有什么区别？"}},[t._v("#")]),t._v(" 21. 常见的 OC 数据类型有哪些？与 C 有什么区别？")]),t._v(" "),a("p",[t._v("常见的有： "),a("code",[t._v("NSInteger、CGFloat、 NSString、 NSNumber、 NSArray、 NSDate")])]),t._v(" "),a("p",[a("code",[t._v("NSInteger：")]),t._v("根据系统32位还是64位来决定本身是 int 还是 long。\n"),a("code",[t._v("CGFloat：")]),t._v("根据系统是32位还是64位来决定本身是 float 还是 double。")]),t._v(" "),a("p",[a("code",[t._v("NSString、 NSNumber、 NSArray、 NSDate")]),t._v(" 都是指针类型的对象，在堆中分配内存；C 中的 char、int 都是在栈中分配内存。")]),t._v(" "),a("h2",{attrs:{id:"_22-id-和-nil-代表什么？nil-和-null-有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-id-和-nil-代表什么？nil-和-null-有什么区别？"}},[t._v("#")]),t._v(" 22. id 和 nil 代表什么？nil 和 null 有什么区别？")]),t._v(" "),a("p",[a("code",[t._v("id ：")]),t._v("类型的指针可以指向任意类型的 OC 对象。\n"),a("code",[t._v("nil ：")]),t._v("代表空值（空指针的值，0）。即对象的引用为空。\n"),a("code",[t._v("null ：")]),t._v("表示指向基本数据类型变量，即C语言变量的指针为空。")]),t._v(" "),a("p",[t._v("在非 ARC 中nil 和 null 可以互换；在 ARC 中，指针和对象的引用要求严格不可以互换。")]),t._v(" "),a("h2",{attrs:{id:"_23-向一个-nil-对象发送消息会发生什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-向一个-nil-对象发送消息会发生什么？"}},[t._v("#")]),t._v(" 23. 向一个 nil 对象发送消息会发生什么？")]),t._v(" "),a("p",[t._v("OC 中 nil 对象发送消息是有效的， 但是在运行时没有任何作用，也不会崩溃。")]),t._v(" "),a("p",[t._v("如果一个方法返回的是一个对象，那么发送给 nil 的消息返回0 。如果方法返回值为结构体，那么发送给 nil 对象的消息返回0 。")]),t._v(" "),a("h2",{attrs:{id:"_24-类方法和实例方法有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-类方法和实例方法有什么区别？"}},[t._v("#")]),t._v(" 24. 类方法和实例方法有什么区别？")]),t._v(" "),a("p",[a("strong",[t._v("类方法：")])]),t._v(" "),a("ol",[a("li",[t._v("属于类对象，只能类对象来调用。")]),t._v(" "),a("li",[t._v("类方法可以调用任何其他类方法。")]),t._v(" "),a("li",[t._v("不能访问成员变量，不能直接调用对象方法。")])]),t._v(" "),a("p",[a("strong",[t._v("实例方法：")])]),t._v(" "),a("ol",[a("li",[t._v("属于实例对象，只能实例对象来调用。")]),t._v(" "),a("li",[t._v("实例方法可以调用实例方法。")]),t._v(" "),a("li",[t._v("能访问实例变量，能调用类方法。")])]),t._v(" "),a("h2",{attrs:{id:"_25-block-和-weak-修饰符有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-block-和-weak-修饰符有什么区别？"}},[t._v("#")]),t._v(" 25.  _block 和 _weak 修饰符有什么区别？")]),t._v(" "),a("p",[a("code",[t._v("_block")]),t._v(" 在 arc 和 mrc 下都能使用，可以修饰对象，也可以修饰基本数据类型。\n"),a("code",[t._v("_weak")]),t._v("只能在 arc 下使用，只能修饰对象，不能修饰基本数据类型。\n"),a("code",[t._v("_block")]),t._v("修饰的对象可以在 block 中进行重新赋值，"),a("code",[t._v("_weak")]),t._v(" 不能。")]),t._v(" "),a("h2",{attrs:{id:"_26-property-的本质是什么？成员变量、getter、setter-方法是如何生存并添加到类中的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-property-的本质是什么？成员变量、getter、setter-方法是如何生存并添加到类中的？"}},[t._v("#")]),t._v(" 26. @property 的本质是什么？成员变量、getter、setter 方法是如何生存并添加到类中的？")]),t._v(" "),a("p",[a("code",[t._v("@property")]),t._v(" 的创建属性的本质是："),a("code",[t._v("ivar（实例变量）+ getter + setter 方法 。")])]),t._v(" "),a("h2",{attrs:{id:"_27-category是什么？重写一个类的方式用继承好还是分类好？为什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-category是什么？重写一个类的方式用继承好还是分类好？为什么？"}},[t._v("#")]),t._v(" 27. Category是什么？重写一个类的方式用继承好还是分类好？为什么？")]),t._v(" "),a("p",[a("code",[t._v("Category")]),t._v("是类别，又叫分类；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系")]),t._v(" "),a("h2",{attrs:{id:"_28-什么情况使用-weak-关键字，相比-assign-有什么不同？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-什么情况使用-weak-关键字，相比-assign-有什么不同？"}},[t._v("#")]),t._v(" 28. 什么情况使用 weak 关键字，相比 assign 有什么不同？")]),t._v(" "),a("p",[a("strong",[t._v("首先明白什么情况使用weak关键字？")])]),t._v(" "),a("p",[t._v("在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用"),a("code",[t._v("weak")]),t._v("来解决,比如:"),a("code",[t._v("delegate")]),t._v("代理属性，代理属性也可使用"),a("code",[t._v("assign")]),t._v("\n自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong，但是建议使用weak")]),t._v(" "),a("p",[a("strong",[t._v("weak 和 assign的不同点:")])]),t._v(" "),a("p",[t._v("weak策略在属性所指的对象遭到摧毁时，系统会将weak修饰的属性对象的指针指向nil，在OC给nil发消息是不会有什么问题的；\n如果使用assign策略在属性所指的对象遭到摧毁时，属性对象指针还指向原来的对象，由于对象已经被销毁，这时候就产生了野指针，如果这时候在给此对象发送消息，很容造成程序奔溃;\nassigin 可以用于修饰非OC对象, 而weak必须用于OC对象;")]),t._v(" "),a("h2",{attrs:{id:"_29-怎么用-copy-关键字？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-怎么用-copy-关键字？"}},[t._v("#")]),t._v(" 29. 怎么用 copy 关键字？")]),t._v(" "),a("p",[t._v("一般使用"),a("code",[t._v("retain")]),t._v("或者"),a("code",[t._v("strong")]),t._v("修饰属性时，是使引用对象的指针指向同一个对象，即为同一块内存地址。只要其中有一个指针变量被修改时所有其他引用该对象的变量都会被改变。")]),t._v(" "),a("p",[t._v("而使用copy关键字修饰在赋值时是释放旧对象，拷贝新对象内容。重新分配了内存地址。以后该指针变量被修改时就不会影响旧对象的内容了。\ncopy只有实现NSCopying协议的对象类型才有效。\n常用于"),a("code",[t._v("NSString")]),t._v("和"),a("code",[t._v("Block")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"_30-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"}},[t._v("#")]),t._v(" 30. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？")]),t._v(" "),a("p",[t._v("该类必须要实现NSCopying协议。实现 "),a("code",[t._v("- (id)copyWithZone:(NSZone *)zone;")]),t._v("方法。"),a("br"),t._v("\n重写copy关键字的setter时，需要调用一下传入对象的copy方法。然后赋值给该setter的方法对应的成员变量。")]),t._v(" "),a("h2",{attrs:{id:"_31-这个写法会出什么问题：-property-copy-nsmutablearray-array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-这个写法会出什么问题：-property-copy-nsmutablearray-array"}},[t._v("#")]),t._v(" 31. 这个写法会出什么问题：@@property (copy) NSMutableArray *array;?")]),t._v(" "),a("p",[t._v("当一个NSMutableArray对象使用"),a("code",[t._v("initWithArray:")]),t._v("初始化方法创建时，并将该对象赋值给了array属性。")]),t._v(" "),a("p",[t._v("那么之后array执行可变数组的方法，比如： "),a("code",[t._v("removeObjectAtIndex:")]),t._v("时会出现"),a("code",[t._v("unrecognized selector sent to instance")]),t._v("的崩溃。\n原因在于array属性在被赋值(setter)的时候默认执行了copy方法后变为了不可变NSArray对象。")]),t._v(" "),a("h2",{attrs:{id:"_32-对于语句-nsstring-obj-nsdata-alloc-init-obj在编译时和运行时分别时什么类型的对象？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-对于语句-nsstring-obj-nsdata-alloc-init-obj在编译时和运行时分别时什么类型的对象？"}},[t._v("#")]),t._v(" 32. 对于语句 NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象？")]),t._v(" "),a("p",[t._v("编译时是NSString的类型；运行时是NSData类型的对象")]),t._v(" "),a("h2",{attrs:{id:"_33-常见的oc的数据类型有那些，-和c的基本数据类型有什么区别？如：nsinteger和int"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-常见的oc的数据类型有那些，-和c的基本数据类型有什么区别？如：nsinteger和int"}},[t._v("#")]),t._v(" 33. 常见的oc的数据类型有那些， 和C的基本数据类型有什么区别？如：NSInteger和int")]),t._v(" "),a("p",[t._v("object-c的数据类型有"),a("code",[t._v("NSString")]),t._v("，"),a("code",[t._v("NSNumber")]),t._v("，"),a("code",[t._v("NSArray")]),t._v("，"),a("code",[t._v("NSMutableArray")]),t._v("，"),a("code",[t._v("NSData")]),t._v("等等，这些都是class，创建后便是对象。\nC语言的基本数据类型int，只是一定字节的内存空间，用于存放数值；")]),t._v(" "),a("p",[a("code",[t._v("NSInteger")]),t._v("是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。\nNSInteger是基本数据类型Int或者Long的别名（NSInteger的定义typedef long NSInteger），它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是Long。")]),t._v(" "),a("h2",{attrs:{id:"_34-id-声明的对象有什么特性？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-id-声明的对象有什么特性？"}},[t._v("#")]),t._v(" 34. id 声明的对象有什么特性？")]),t._v(" "),a("p",[t._v("id 声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象；")]),t._v(" "),a("h2",{attrs:{id:"_35-内存管理的几条原则时什么？按照默认法则-哪些关键字生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_35-内存管理的几条原则时什么？按照默认法则-哪些关键字生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？"}},[t._v("#")]),t._v(" 35. 内存管理的几条原则时什么？按照默认法则, 哪些关键字生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？")]),t._v(" "),a("p",[t._v("Objective-C的内存管理主要有三种方式"),a("code",[t._v("ARC（自动内存计数）")]),t._v("、"),a("code",[t._v("手动内存计数")]),t._v("、"),a("code",[t._v("内存池")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("原则:")]),t._v(" 谁申请，谁释放。遵循Cocoa Touch的使用原则；")]),t._v(" "),a("p",[t._v("内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放，要细心。\n关键字alloc 或 new 生成的对象需要手动释放；\n设置正确的property属性，对于retain需要在合适的地方释放")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_36-浅复制和深复制的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36-浅复制和深复制的区别？"}},[t._v("#")]),t._v(" 36. 浅复制和深复制的区别？")]),t._v(" "),a("p",[t._v("**浅层复制：**只复制指向对象的指针，而不复制引用对象本身。\n**深层复制：**复制引用对象本身。")]),t._v(" "),a("p",[t._v("意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。")]),t._v(" "),a("p",[t._v("**用网上一哥们通俗的话将就是： **\n浅复制好比你和你的影子，你完蛋，你的影子也完蛋\n深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_37-类别的作用？继承和类别在实现中有何区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_37-类别的作用？继承和类别在实现中有何区别？"}},[t._v("#")]),t._v(" 37. 类别的作用？继承和类别在实现中有何区别？")]),t._v(" "),a("p",[a("strong",[t._v("类别:")])]),t._v(" "),a("ol",[a("li",[t._v("将类的实现分散到多个不同文件或多个不同框架中。")]),t._v(" "),a("li",[t._v("创建对私有方法的前向引用。")]),t._v(" "),a("li",[t._v("向对象添加非正式协议。")])]),t._v(" "),a("p",[a("strong",[t._v("category:")])]),t._v(" "),a("ol",[a("li",[t._v("可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。")]),t._v(" "),a("li",[t._v("并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。")])]),t._v(" "),a("p",[a("strong",[t._v("继承:")]),t._v("\n可以增加、扩展父类方法，并且可以增加属性。")]),t._v(" "),a("p",[a("strong",[t._v("类别和类扩展的区别：")])]),t._v(" "),a("ol",[a("li",[t._v("category 和 extensions 的不同在于 extensions 可以添加属性。另外 extensions 添加的方法是必须要实现的。extensions 可以认为是一个私有的 Category 。")]),t._v(" "),a("li",[t._v("分类有名字，类扩展没有分类名字，是一种特殊的分类")]),t._v(" "),a("li",[t._v("分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法")])]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_38-代理的作用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_38-代理的作用？"}},[t._v("#")]),t._v(" 38. 代理的作用？")]),t._v(" "),a("p",[t._v("代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。另外一点，代理可以理解为java中的回调监听机制的一种类似。")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_39-什么时候使用nsmutablearray，什么时候使用nsarray？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_39-什么时候使用nsmutablearray，什么时候使用nsarray？"}},[t._v("#")]),t._v(" 39. 什么时候使用NSMutableArray，什么时候使用NSArray？")]),t._v(" "),a("p",[t._v("当数组在程序运行时，需要不断变化的，使用 NSMutableArray ;\n当数组在初始化后，便不再改变的，使用 NSArray 。")]),t._v(" "),a("p",[t._v("需要指出的是，使用 NSArray 只表明的是该数组在运行时不发生改变，即不能往 NSAarry 的数组里新增和删除元素，但不表明其数组內的元素的内容不能发生改变。\nNSArray 是线程安全的，NSMutableArray不是线程安全的，多线程使用到 NSMutableArray 需要注意。")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_40-谈谈object-c的内存管理方式及过程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_40-谈谈object-c的内存管理方式及过程？"}},[t._v("#")]),t._v(" 40. 谈谈Object-C的内存管理方式及过程？")]),t._v(" "),a("p",[t._v("当你使用"),a("code",[t._v("new")]),t._v(","),a("code",[t._v("alloc")]),t._v("和"),a("code",[t._v("copy")]),t._v("方法创建一个对象时,该对象的保留计数器值为1.当你不再使用该对象时,你要负责向该对象发送一条"),a("code",[t._v("release")]),t._v("或"),a("code",[t._v("autorelease")]),t._v("消息.这样,该对象将在使用寿命结束时被销毁.")]),t._v(" "),a("p",[t._v("当你通过任何其他方法获得一个对象时,则假设该对象的保留计数器值为1,而且已经被设置为自动释放,你不需要执行任何操作来确保该对象被清理.如果你打算在一段时间内拥有该对象,则需要保留它并确保在操作完成时释放它.")]),t._v(" "),a("p",[t._v("如果你保留了某个对象,你需要(最终)释放或自动释放该对象.必须保持"),a("code",[t._v("retain")]),t._v("方法和"),a("code",[t._v("release")]),t._v("方法的使用次数相等.")]),t._v(" "),a("hr")])}),[],!1,null,null,null);_.default=e.exports}}]);