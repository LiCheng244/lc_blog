(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{309:function(e,v,_){e.exports=_.p+"assets/img/20090304.3a31a3b3.png"},583:function(e,v,_){"use strict";_.r(v);var a=_(6),o=Object(a.a)({},(function(){var e=this,v=e.$createElement,a=e._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",[e._v(" SDWebImage 框架实现原理")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("引言")])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"一-sdwebimage-概论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-sdwebimage-概论"}},[e._v("#")]),e._v(" 一. SDWebImage 概论")]),e._v(" "),a("ul",[a("li",[e._v("提供了一个UIImageView的category用来加载网络图片并且对网络图片的缓存进行管理")]),e._v(" "),a("li",[e._v("采用异步方式来下载网络图片")]),e._v(" "),a("li",[e._v("采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存。")]),e._v(" "),a("li",[e._v("支持GIF动画")]),e._v(" "),a("li",[e._v("支持WebP格式")]),e._v(" "),a("li",[e._v("同一个URL的网络图片不会被重复下载")]),e._v(" "),a("li",[e._v("失效的URL不会被无限重试")]),e._v(" "),a("li",[e._v("耗时操作都在子线程，确保不会阻塞主线程")]),e._v(" "),a("li",[e._v("使用GCD和ARC")]),e._v(" "),a("li",[e._v("支持Arm64")])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"二-内部实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-内部实现原理"}},[e._v("#")]),e._v(" 二. 内部实现原理")]),e._v(" "),a("ol",[a("li",[e._v("入口 "),a("code",[e._v("setImageWithURL:placeholderImage:options:")]),e._v("会先把 "),a("code",[e._v("placeholderImage")]),e._v("显示，然后 "),a("strong",[e._v("SDWebImageManager")]),e._v(" 根据 URL 开始处理图片。")]),e._v(" "),a("li",[e._v("进入 "),a("strong",[e._v("SDWebImageManager")]),e._v(" "),a("code",[e._v("-downloadWithURL:delegate:options:userInfo:")]),e._v("，交给 "),a("strong",[e._v("SDImageCache")]),e._v(" 从缓存查找图片是否已经下载 "),a("code",[e._v("queryDiskCacheForKey:delegate:userInfo:")]),e._v(".")]),e._v(" "),a("li",[e._v("先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，"),a("strong",[e._v("SDImageCacheDelegate")]),e._v(" 回调 "),a("code",[e._v("imageCache:didFindImage:forKey:userInfo:")]),e._v("到 "),a("strong",[e._v("SDWebImageManager")]),e._v("。")]),e._v(" "),a("li",[a("strong",[e._v("SDWebImageManagerDelegate")]),e._v(" 回调 "),a("code",[e._v("webImageManager:didFinishWithImage:")]),e._v(" 到 "),a("strong",[e._v("UIImageView+WebCache")]),e._v(" 等前端展示图片。")]),e._v(" "),a("li",[e._v("如果内存缓存中没有，生成 "),a("code",[e._v("NSInvocationOperation")]),e._v(" 添加到队列开始从硬盘查找图片是否已经缓存。")]),e._v(" "),a("li",[e._v("根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 "),a("code",[e._v("notifyDelegate:")]),e._v("。")]),e._v(" "),a("li",[e._v("如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。"),a("strong",[e._v("SDImageCacheDelegate")]),e._v(" 回调 "),a("code",[e._v("imageCache:didFindImage:forKey:userInfo:")]),e._v("。\n进而回调展示图片。")]),e._v(" "),a("li",[e._v("如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 "),a("code",[e._v("imageCache:didNotFindImageForKey:userInfo:")]),e._v("。")]),e._v(" "),a("li",[e._v("共享或重新生成一个下载器 "),a("strong",[e._v("SDWebImageDownloader")]),e._v(" 开始下载图片。")]),e._v(" "),a("li",[e._v("图片下载由 "),a("strong",[e._v("NSURLConnection")]),e._v(" 来做，实现相关 "),a("code",[e._v("delegate")]),e._v(" 来判断图片下载中、下载完成和下载失败。")]),e._v(" "),a("li",[a("code",[e._v("connection:didReceiveData:")]),e._v("中利用 ImageIO 做了按图片下载进度加载效果。")]),e._v(" "),a("li",[a("code",[e._v("connectionDidFinishLoading:")]),e._v("数据下载完成后交给 "),a("strong",[e._v("SDWebImageDecoder")]),e._v(" 做图片解码处理。")]),e._v(" "),a("li",[e._v("图片解码处理在一个 "),a("strong",[e._v("NSOperationQueue")]),e._v(" 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。")]),e._v(" "),a("li",[e._v("在主线程 "),a("code",[e._v("notifyDelegateOnMainThreadWithInfo:")]),e._v("宣告解码完成，"),a("code",[e._v("imageDecoder:didFinishDecodingImage:userInfo:")]),e._v("回调给 "),a("strong",[e._v("SDWebImageDownloader")]),e._v("。")]),e._v(" "),a("li",[a("code",[e._v("imageDownloader:didFinishWithImage:")]),e._v("回调给 "),a("strong",[e._v("SDWebImageManager")]),e._v(" 告知图片下载完成。")]),e._v(" "),a("li",[e._v("通知所有的 "),a("code",[e._v("downloadDelegates")]),e._v("下载完成，回调给需要的地方展示图片。")]),e._v(" "),a("li",[e._v("将图片保存到 "),a("strong",[e._v("SDImageCache")]),e._v(" 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。")]),e._v(" "),a("li",[a("strong",[e._v("SDImageCache")]),e._v(" 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。")]),e._v(" "),a("li",[e._v("SDWI 也提供了** UIButton+WebCache** 和 "),a("strong",[e._v("MKAnnotationView+WebCache")]),e._v("，方便使用。")]),e._v(" "),a("li",[a("strong",[e._v("SDWebImagePrefetcher")]),e._v(" 可以预先下载图片，方便后续使用。")])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"三-sdwebimage-流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-sdwebimage-流程"}},[e._v("#")]),e._v(" 三. SDWebImage 流程")]),e._v(" "),a("p",[a("img",{attrs:{src:_(309),alt:""}})]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"四-如何数据管理的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-如何数据管理的"}},[e._v("#")]),e._v(" 四. 如何数据管理的?")]),e._v(" "),a("p",[a("code",[e._v("SDImageCache")]),e._v("分两个部分，一个是内存层面的，一个是硬盘层面的。")]),e._v(" "),a("p",[a("strong",[e._v("内存层面：")])]),e._v(" "),a("p",[e._v("相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。\n用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。")]),e._v(" "),a("p",[a("strong",[e._v("硬盘层面：")])]),e._v(" "),a("p",[e._v("当"),a("code",[e._v("SDWebImageManager")]),e._v("向 "),a("code",[e._v("SDImageCache")]),e._v(" 要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘， 将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。")]),e._v(" "),a("br")])}),[],!1,null,null,null);v.default=o.exports}}]);