(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{432:function(t,a,s){"use strict";s.r(a);var e=s(6),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("hr"),t._v(" "),s("h4",{attrs:{id:"_1-frame和bounds有什么不同？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-frame和bounds有什么不同？"}},[t._v("#")]),t._v(" 1. frame和bounds有什么不同？")]),t._v(" "),s("p",[s("code",[t._v("frame")]),t._v("\n指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）")]),t._v(" "),s("p",[s("code",[t._v("bounds")]),t._v("\n指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_2-uiview和calayer是什么关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-uiview和calayer是什么关系"}},[t._v("#")]),t._v(" 2. UIView和CALayer是什么关系?")]),t._v(" "),s("p",[s("code",[t._v("UIView")]),t._v("显示在屏幕上归功于"),s("code",[t._v("CALayer")]),t._v("，通过调用"),s("code",[t._v("drawRect")]),t._v("方法来渲染自身的内容，调节CALayer属性可以调整UIView的外观，UIView继承自UIResponder，比起CALayer可以响应用户事件，Xcode6之后可以方便的通过视图调试功能查看图层之间的关系")]),t._v(" "),s("p",[t._v("UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它内部是由"),s("code",[t._v("Core Animation")]),t._v("来实现的，它真正的绘图部分，是由一个叫"),s("code",[t._v("CALayer(Core Animation Layer)")]),t._v("的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和坐标有关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性")]),t._v(" "),s("p",[t._v("UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，如：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("- (class) layerClass {\n    // 使某个UIView的子类使用GL来进行绘制\n    return ([CAEAGLLayer class]);\n}\n")])])]),s("p",[t._v("UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的显示。例如下面的代码会在目标View上敷上一层黑色的透明薄膜。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("grayCover = [[CALayer alloc]init];\ngrayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor;\n[self.layer addSubLayer:grayCover];\n")])])]),s("p",[t._v("补充部分，这部分有深度了，大致了解一下吧，UIView的layer树形在系统内部被系统维护着三份copy")]),t._v(" "),s("ul",[s("li",[t._v("逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份")]),t._v(" "),s("li",[t._v("动画树，这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作")]),t._v(" "),s("li",[t._v("显示树，这棵树的内容是当前正被显示在屏幕上的内容\n这三棵树的逻辑结构都是一样的，区别只有各自的属性")])]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_3-iboutlet连出来的视图属性为什么可以被设置成weak"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-iboutlet连出来的视图属性为什么可以被设置成weak"}},[t._v("#")]),t._v(" 3. IBOutlet连出来的视图属性为什么可以被设置成weak?")]),t._v(" "),s("p",[t._v("因为父控件的subViews数组已经对它有一个强引用.")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_4-ib中user-defined-runtime-attributes如何使用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-ib中user-defined-runtime-attributes如何使用？"}},[t._v("#")]),t._v(" 4. IB中User Defined Runtime Attributes如何使用？")]),t._v(" "),s("p",[s("code",[t._v("User Defined Runtime Attributes")]),t._v("是一个不被看重但功能非常强大的的特性，它能够通过KVC的方式配置一些你在interface builder中不能配置的属性\n当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的 viewcontroller")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_5-pushviewcontroller和presentviewcontroller有什么区别？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-pushviewcontroller和presentviewcontroller有什么区别？"}},[t._v("#")]),t._v(" 5. pushViewController和presentViewController有什么区别？")]),t._v(" "),s("p",[t._v("两者都是在多个试图控制器间跳转的函数")]),t._v(" "),s("p",[s("code",[t._v("presentViewController")]),t._v("提供的是一个模态视图控制器(modal)\n"),s("code",[t._v("pushViewController")]),t._v("提供一个栈控制器数组，push/pop")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_6-请简述uitableview的复用机制？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-请简述uitableview的复用机制？"}},[t._v("#")]),t._v(" 6. 请简述UITableView的复用机制？")]),t._v(" "),s("p",[t._v("每次创建 cell 的时候通过"),s("code",[t._v("dequeueReusableCellWithIdentifier:")]),t._v("方法创建cell，它先到缓存池中找指定标识的cell，如果没有就直接返回nil\n如果没有找到指定标识的cell，那么会通过"),s("code",[t._v("initWithStyle:reuseIdentifier:")]),t._v("创建一个cell\n当cell离开界面就会被放到缓存池中，以供下次复用")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_7-使用drawrect有什么影响？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-使用drawrect有什么影响？"}},[t._v("#")]),t._v(" 7. 使用drawRect有什么影响？")]),t._v(" "),s("p",[s("code",[t._v("drawRect")]),t._v("方法依赖Core Graphics框架来进行自定义的绘制")]),t._v(" "),s("p",[s("strong",[t._v("缺点：")]),t._v("\n它处理touch事件时每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了")]),t._v(" "),s("p",[t._v("这个方法的调用机制也是非常特别. 当你调用 "),s("code",[t._v("setNeedsDisplay")]),t._v("方法时, UIKit 将会把当前图层标记为dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将标记为 dirty 的图层重新建立Core Graphics上下文,然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_8-描述下sdwebimage里面给uiimageview加载图片的逻辑"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-描述下sdwebimage里面给uiimageview加载图片的逻辑"}},[t._v("#")]),t._v(" 8. 描述下SDWebImage里面给UIImageView加载图片的逻辑?")]),t._v(" "),s("p",[t._v("SDWebImage 中为 UIImageView 提供了一个分类"),s("code",[t._v("UIImageView+WebCache.h")]),t._v(", 这个分类中有一个最常用的接口"),s("code",[t._v("sd_setImageWithURL:placeholderImage:")]),t._v("，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后在替换占位图片")]),t._v(" "),s("p",[s("strong",[t._v("加载图片的过程大致如下：")])]),t._v(" "),s("ol",[s("li",[t._v("首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存")]),t._v(" "),s("li",[t._v("如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来")]),t._v(" "),s("li",[t._v("如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片")]),t._v(" "),s("li",[t._v("下载后的图片会加入缓存中，并写入磁盘中")])]),t._v(" "),s("p",[t._v("整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"_9-你是怎么封装一个-view-的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-你是怎么封装一个-view-的？"}},[t._v("#")]),t._v(" 9. 你是怎么封装一个 view 的？")]),t._v(" "),s("p",[t._v("可以通过纯代码或者xib的方式来封装子控件, 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  纯代码初始化控件时一定会走这个方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instancetype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("initWithFrame"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CGRect"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("frame"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),t._v(" initWithFrame"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("frame"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" setup"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  通过xib初始化控件时一定会走这个方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("initWithCoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSCoder "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("aDecoder "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),t._v(" initWithCoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("aDecoder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" setup"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("setup "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化代码")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" ```\n\n___\n#### "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10.")]),t._v(" 如何进行系统版本的适配"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("\n通过判断版本来控制，来执行响应的代码\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("功能适配："),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("保证同一个功能在"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("、"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v("上都能用\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("UI适配："),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("保证各自的显示风格\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("版本号判断："),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" `#define "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iOS8")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("UIDevice currentDevice"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("systemVersion doubleValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("`\n\n___\n#### "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11.")]),t._v(" UIScrollView的contentSize能否在viewDidLoad中设置？\n可以。因为UIScrollView的内容尺寸是根据其内部的内容来决定的，所以是可以在viewDidLoad中设置的"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("补充：（这仅仅是一种特殊情况）"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n前提，控制器B是控制器A的一个子控制器，且控制器B的内容只在控制器A的view的部分区域中显示假设控制器B的view中有一个UIScrollView这样一个子控件\n\n如果此时在控制器B的viewDidLoad中设置UIScrollView的contentSize的话会导致不准确的问题\n因为任何控制器的view在viewDidLoad的时候的尺寸都是不准确的，如果有子控件的尺寸依赖父控件的尺寸，在这个方法中设置会导致子控件的frame不准确，所以这时应该在下面的方法中设置子控件的尺寸 `"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("viewDidLayoutSubviews"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("`\n\n\n___\n#### "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12.")]),t._v(" 触摸事件的传递？\n触摸事件的传递是从父控件传递到子控件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("不能接受触摸事件的四种情况"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" `不接收用户交互`，即：userInteractionEnabled "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NO"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" `隐藏`，即：hidden "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" YES"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v(" `透明`，即：alpha "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.01")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.")]),t._v(" `未启用`，即：enabled "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NO"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("如何找到最合适处理事件的控件："),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" 首先，判断自己能否接收触摸事件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 可以通过重写`hitTest"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("withEvent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("`方法验证\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" 其次，判断触摸点是否在自己身上"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 对应方法`pointInside"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("withEvent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("`\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v(" 从后往前"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("先遍历最后添加的子控件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("遍历子控件，重复前面的两个步骤\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.")]),t._v(" 如果没有符合条件的子控件，那么就自己处理\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("提示"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n`UIImageView` 的 `userInteractionEnabled` 默认就是NO，因此`UIImageView` 以及它的子控件默认是不能接收触摸事件的\n\n___\n#### "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("13.")]),t._v(" 关于事件响应者链"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" 如果当前view是控制器的view，那么就传递给控制器\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" 如果控制器不存在，则将其传递给它的父控件\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" 在视图层次结构的最顶层视图也不能处理接收到的事件或消息，则将事件或消息传递给UIWindow对象进行处理\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" 如果UIWindow对象也不处理，则将事件或消息传递给UIApplication对象\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" 如果UIApplication也不能处理该事件或消息，则将其丢弃\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("补充：如何判断上一个响应者"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" 如果当前这个view是控制器的view，那么`控制器`就是上一个响应者\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" 如果当前这个view不是控制器的view，那么`父控件`就是上一个响应者\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("http"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//ogewbn1ek.bkt.clouddn.com/xiangyingzhelian.png)")]),t._v("\n\n___\n#### "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("14.")]),t._v(" loadView的作用？\nloadView用来自定义view，只要实现了这个方法，其他通过xib或storyboard创建的view都不会被加载\n\n看懂控制器view创建的这个图就行 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("http"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//ogewbn1ek.bkt.clouddn.com/1BA708AD-5018-462F-8F23-48475734B7D1.png)")]),t._v("\n\n___\n\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);