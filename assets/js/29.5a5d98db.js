(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{208:function(_,v,i){"use strict";i.r(v);var l=i(6),e=Object(l.a)({},(function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("blockquote",[i("p",[i("strong",[_._v("引言：")])]),_._v(" "),i("p",[_._v("官方文档给出的区别:\n"),i("code",[_._v("load")]),_._v("是只要类所在文件被引用就会被调用，而"),i("code",[_._v("initialize")]),_._v("是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有"),i("code",[_._v("load")]),_._v("调用；但即使类文件被引用进来，但是没有使用，那么"),i("code",[_._v("initialize")]),_._v("也不会被调用。")])]),_._v(" "),i("br"),_._v("\n### I. load和initialize的共同特点\n____\n"),i("ul",[i("li",[_._v("在不考虑开发者主动使用的情况下, 两个方法系统最多会调用一次 ;")]),_._v(" "),i("li",[_._v("如果父类和子类都被调用，父类的调用一定在子类之前 ;")]),_._v(" "),i("li",[_._v("都是为了应用运行提前创建合适的运行环境 ;")]),_._v(" "),i("li",[_._v("在使用时都不要过重地依赖于这两个方法，除非真正必要 ;")])]),_._v(" "),i("br"),_._v("\n### II. +load方法\n____\n"),i("ul",[i("li",[_._v("调用时机比较早，运行环境有不确定因素。通常都是 App 启动前进行调用，当 "),i("code",[_._v("load")]),_._v(" 调用的时候，并不能保证所有类都加载完成且可用，必要时还要自己负责做"),i("code",[_._v("auto release")]),_._v("处理;")]),_._v(" "),i("li",[_._v("load类所在文件被引用就会调用, 如果没有被引用到项目中, 就不会调用;")]),_._v(" "),i("li",[_._v("如果子类没有实现该方法, 该子类不会是不会调用该方法的, 就算父类实现了也不会调用父类的"),i("code",[_._v("load")]),_._v("方法;")]),_._v(" "),i("li",[_._v("如果子类实现了, 父类的 "),i("code",[_._v("load")]),_._v(" 方法会优先于子类调用,类别的"),i("code",[_._v("load")]),_._v("方法一般最后调用不会直接触发"),i("code",[_._v("initialize")]),_._v("的调用;")])]),_._v(" "),i("h4",{attrs:{id:"总结"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结:")]),_._v(" "),i("blockquote",[i("p",[_._v("在程序启动之前会调用所有的类的(手动实现的) +load 方法(没有实现就不调用咯),按(父类->子类->类别)的顺序调用.")])]),_._v(" "),i("br"),_._v("\n### III. +initialize方法\n____\n"),i("ul",[i("li",[i("code",[_._v("initialize")]),_._v(" 的自然调用是在第一次主动使用当前类或者子类时,在第一个方法(alloc)被调用前调用 ;")]),_._v(" "),i("li",[_._v("在 "),i("code",[_._v("initialize")]),_._v(" 方法被调用时，应用的运行环境基本健全 ;")]),_._v(" "),i("li",[i("code",[_._v("initialize")]),_._v(" 的运行过程中是能保证线程安全的 ;")]),_._v(" "),i("li",[_._v("和 load 不同，如果子类不实现 "),i("code",[_._v("initialize")]),_._v(" 方法，会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super 调用 ;")])]),_._v(" "),i("h4",{attrs:{id:"调用顺序"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#调用顺序"}},[_._v("#")]),_._v(" 调用顺序:")]),_._v(" "),i("ul",[i("li",[_._v("如果父类的 "),i("code",[_._v("initialize")]),_._v(" 方法没有被调用过会先调用父类的 "),i("code",[_._v("initialize")]),_._v(" 方法 ;")]),_._v(" "),i("li",[_._v("如果该类有类别只会调用类别的 "),i("code",[_._v("+initialize")]),_._v(" (如果有多个类别会调用某一个类别的 "),i("code",[_._v("initialize")]),_._v(" 方法,其他的不会调用);")])]),_._v(" "),i("h4",{attrs:{id:"总结-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[_._v("#")]),_._v(" 总结:")]),_._v(" "),i("blockquote",[i("p",[_._v("在程序启动之后,在第一次创建这个类的对象的时候(也就是分配内存空间alloc的时候),会调用该类的"),i("code",[_._v("+initialize")]),_._v(" 方法且只调用一次 ;")])])])}),[],!1,null,null,null);v.default=e.exports}}]);