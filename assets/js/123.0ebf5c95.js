(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{428:function(e,t,s){"use strict";s.r(t);var a=s(6),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",[e._v("关于 drawRect 和 setNeedsDisplay")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("引言:")]),e._v(" "),s("p",[e._v("iOS的绘图操作是在UIView类的drawRect方法中完成的，所以如果我们要想在一个UIView中绘图，需要写一个扩展UIView 的类，并重写drawRect方法，在这里进行绘图操作，程序会自动调用此方法进行绘图。")])]),e._v(" "),s("br"),e._v(" "),s("h2",{attrs:{id:"一-drawrect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一-drawrect"}},[e._v("#")]),e._v(" 一. drawRect")]),e._v(" "),s("p",[e._v("当一个视图被刷新时，该视图的"),s("code",[e._v("drawRect")]),e._v("函数被调用。每次调用该函数时，它都绘制内容到视图。\n由于"),s("code",[e._v("drawRect")]),e._v("调用非常频繁，所以它应该是一个"),s("em",[e._v("非常轻量级的函数")]),e._v("。不要在drawRect函数内分配内存，"),s("strong",[e._v("而且坚决不要从你的代码中直接调用drawRect函数")]),e._v("）。")]),e._v(" "),s("br"),e._v(" "),s("h2",{attrs:{id:"二-setneedsdisplay"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二-setneedsdisplay"}},[e._v("#")]),e._v(" 二. setNeedsDisplay")]),e._v(" "),s("p",[e._v("那么，如果你不能在自己的代码中调用"),s("code",[e._v("drawRect")]),e._v("函数，如何才能刷新视图呢？答案是调用函数"),s("code",[e._v("setNeedsDisplay")]),e._v("。")]),e._v(" "),s("p",[e._v("由于移动设备上资源稀缺，iOS会尽可能试图优化资源密集的处理过程。向屏幕上绘制内容需要大量的资源，所以使用setNeedsDisplay函数设置视图，而不是手动调用drawRect函数刷新视图。\n当一个视图调用setNeedsDisplay函数设置了标志，iOS会在最有效率的时候自动刷新视图。drawRect和setNeedsDisplay之间的时间延迟难以察觉，在毫秒级。但是，通过让iOS自己调度而调用drawRect， iOS可以优化多个drawRect函数调用，然后以最高效的方式来执行命令。")]),e._v(" "),s("br"),e._v(" "),s("h2",{attrs:{id:"三-注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三-注意事项"}},[e._v("#")]),e._v(" 三. 注意事项")]),e._v(" "),s("p",[e._v("为了优化iOS应用程序的性能，iOS只绘制屏幕上可见的视图。这意味着，如果一个视图在屏幕之外或者被另一个视图所覆盖，iOS不会刷新该视图的这部分内容。\n"),s("br")])])}),[],!1,null,null,null);t.default=r.exports}}]);