(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{533:function(v,e,o){"use strict";o.r(e);var a=o(6),_=Object(a.a)({},(function(){var v=this,e=v.$createElement,o=v._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h1",[v._v("被神化的【MVVM 模式】")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("引言:")]),v._v(" "),o("p",[v._v("MVVM 是 "),o("code",[v._v("Model-View-ViewModel")]),v._v("的简写。")]),v._v(" "),o("p",[v._v("相对于 MVC 的历史来说，MVVM 是一个相当新的架构，MVVM 最早于 2005 年被微软的 WPF 和 Silverlight 的架构师 John Gossman 提出，并且应用在微软的软件开发中。当时 MVC 已经被提出了 20 多年了，可见两者出现的年代差别有多大。")]),v._v(" "),o("p",[v._v("MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。所以，MVVM 模式有些时候又被称作："),o("code",[v._v("model-view-binder")]),v._v(" 模式。")]),v._v(" "),o("p",[v._v("具体在 iOS 中，可以使用 "),o("code",[v._v("KVO")]),v._v(" 或 "),o("code",[v._v("Notification")]),v._v(" 技术达到这种效果。")])]),v._v(" "),o("br"),v._v(" "),o("h2",{attrs:{id:"一-mvvm-的神化"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#一-mvvm-的神化"}},[v._v("#")]),v._v(" 一. MVVM 的神化")]),v._v(" "),o("p",[v._v("在使用中，我发现大家对于 "),o("code",[v._v("MVVM")]),v._v(" 以及 MVVM 衍生出来的框架（比如 "),o("code",[v._v("ReactiveCocoa")]),v._v("）有一种「敬畏」感。这种「敬畏」感某种程度上就像对神一样，这主要表现在我没有听到大家对于 MVVM 的任何批评。")]),v._v(" "),o("p",[v._v("我感觉原因首先是 MVVM 并没有很大程度上普及，大家对于新技术一般都不熟，进而不敢妄加评论。另外，ReactiveCocoa 本身上手的复杂性，也让很多人感觉到这种技术很高深难懂，进而加重了大家对它的「敬畏」。")]),v._v(" "),o("br"),v._v(" "),o("h2",{attrs:{id:"二-mvvm-的作用和问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#二-mvvm-的作用和问题"}},[v._v("#")]),v._v(" 二. MVVM 的作用和问题")]),v._v(" "),o("p",[v._v("MVVM 在实际使用中，确实能够使得 Model 层和 View 层解耦，但是如果你需要实现 MVVM 中的双向绑定的话，那么通常就需要引入更多复杂的框架来实现了。")]),v._v(" "),o("p",[v._v("对此，MVVM 的作者 "),o("code",[v._v("John Gossman")]),v._v(" 的 批评 应该是最为中肯的。John Gossman 对 MVVM 的批评主要有两点：")]),v._v(" "),o("p",[o("strong",[v._v("第一点：")]),v._v("\n数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。")]),v._v(" "),o("p",[o("strong",[v._v("第二点：")]),v._v("\n对于过大的项目，数据绑定需要花费更多的内存。")]),v._v(" "),o("p",[v._v("某种意义上来说，我认为就是数据绑定使得 MVVM 变得复杂和难用了。但是，这个缺点同时也被很多人认为是优点。")]),v._v(" "),o("br"),v._v(" "),o("h2",{attrs:{id:"三-reactivecocoa"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#三-reactivecocoa"}},[v._v("#")]),v._v(" 三. ReactiveCocoa")]),v._v(" "),o("p",[o("code",[v._v("函数式编程（Functional Programming）")]),v._v("和"),o("code",[v._v("响应式编程（React Programming）")]),v._v("也是当前很火的两个概念，它们的结合可以很方便地实现数据的绑定。于是，在 iOS 编程中，ReactiveCocoa 横空出世了，它的概念都非常 新，包括：")]),v._v(" "),o("ul",[o("li",[o("p",[v._v("函数式编程（Functional Programming），函数也变成一等公民了，可以拥有和对象同样的功能，例如当成参数传递，当作返回值等。看看 Swift 语言带来的众多函数式编程的特性，就你知道这多 Cool 了。")])]),v._v(" "),o("li",[o("p",[v._v("响应式编程（React Programming），原来我们基于事件（Event）的处理方式都弱了，现在是基于输入（在 ReactiveCocoa 里叫 Signal）的处理方式。输入还可以通过函数式编程进行各种 Combine 或 Filter，尽显各种灵活的处理。")])]),v._v(" "),o("li",[o("p",[v._v("无状态（Stateless），状态是函数的魔鬼，无状态使得函数能更好地测试。")])]),v._v(" "),o("li",[o("p",[v._v("不可修改（Immutable），数据都是不可修改的，使得软件逻辑简单，也可以更好地测试。")])])]),v._v(" "),o("p",[v._v("哇，所有这些都太 Cool 了。当我看到的时候，我都鸡冻了！")]),v._v(" "),o("br"),v._v(" "),o("h2",{attrs:{id:"四-客观评价-mvvm-和-reactivecocoa"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#四-客观评价-mvvm-和-reactivecocoa"}},[v._v("#")]),v._v(" 四. 客观评价 MVVM 和 ReactiveCocoa")]),v._v(" "),o("p",[v._v("但是但是，我突然想到，我好象只需要一个"),o("code",[v._v("ViewModel")]),v._v(" 而已，我完全可以简单地做一个 ViewModel 的工厂类或 Service 类就可以了，为什么要引入这么多框架？现有的 MVC 真的有那么大的问题吗？")]),v._v(" "),o("p",[v._v("直到现在，"),o("code",[v._v("ReactiveCocoa")]),v._v("在国内外还都是在小众领域，没有被大量接受成为主流的编程框架。不只是在 iOS 语言，在别的语言中，例如 Java 中的 RxJava 也同样没有成为主流。")]),v._v(" "),o("p",[v._v("我在这里，不是想说 ReactiveCocoa 不好，也不是想说 MVVM 不好，而是想让大家都能够有一个客观的认识。ReactiveCocoa 和 MVVM 不应该被神化，它是一种新颖的编程框架，能够解决旧有编程框架的一些问题，但是也会带来一些新问题，仅此而已。如果不能使好的驾驭 ReactiveCocoa，同样会造成 Controller 代码过于复杂，代码逻辑不易维护的问题。")]),v._v(" "),o("br")])}),[],!1,null,null,null);e.default=_.exports}}]);