(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{536:function(e,v,_){"use strict";_.r(v);var o=_(6),l=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",[e._v("被误解的【MVC 模式】")]),e._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[e._v("引言:")]),e._v(" "),_("p",[e._v("MVC，全称是 Model View Controller，是模型 (model), 视图 (view) , 控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。")]),e._v(" "),_("p",[e._v("MVC 的概念最早出现在二十世纪八十年代的 施乐帕克 实验室中（对，就是那个发明图形用户界面和鼠标的实验室），当时施乐帕克为 Smalltalk 发明了这种软件设计模式。")]),e._v(" "),_("p",[e._v("现在，MVC 已经成为主流的客户端编程框架，在 iOS 开发中，系统为我们实现好了公共的视图类：UIView，和控制器类：UIViewController。大多数时候，我们都需要继承这些类来实现我们的程序逻辑，因此，我们几乎逃避不开 MVC 这种设计模式。")]),e._v(" "),_("p",[e._v("但是，几十年过去了，我们对于 MVC 这种设计模式真的用得好吗？其实不是的，MVC 这种分层方式虽然清楚，但是如果使用不当，很可能让大量代码都集中在 Controller 之中，让 MVC 模式变成了 Massive View Controller 模式")])]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"一-controller-臃肿问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一-controller-臃肿问题"}},[e._v("#")]),e._v(" 一. Controller 臃肿问题")]),e._v(" "),_("h3",{attrs:{id:"「什么样的内容才应该放到-controller-中？」"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#「什么样的内容才应该放到-controller-中？」"}},[e._v("#")]),e._v(" 「什么样的内容才应该放到 Controller 中？」")]),e._v(" "),_("p",[e._v("我们来看看"),_("code",[e._v("MVC")]),e._v("这种架构的特点。其实设计模式很多时候是为了"),_("code",[e._v("Don't repeat yourself")]),e._v("原则来做的，该原则要求能够复用的代码要尽量复用，来保证重用。在 MVC 这种设计模式中，我们发现 View 和 Model 都是符合这种原则的。")]),e._v(" "),_("p",[e._v("对于 "),_("code",[e._v("View")]),e._v(" 来说，你如果抽象得好，那么一个 App 的动画效果可以很方便地移植到别的 App 上，而 Github 上也有很多 UI 控件，这些控件都是在 View 层做了很好的封装设计，使得它能够方便地开源给大家复用。")]),e._v(" "),_("p",[e._v("对于 "),_("code",[e._v("Model")]),e._v("来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。比如我当时在做有道云笔记 iPad 版的时候，我们就直接和 iOS 版复用了所有的 Model 层的代码。在创业做猿题库客户端时，iOS 和 iPad 版的 Model 层代码再次被复用上了。当然，因为和业务本身的数据意义相关，Model 层的复用大多数是在一个产品内部，不太可能像 View 层那样开源给社区。")]),e._v(" "),_("p",[e._v("说完 View 和 Model 了，那我们想想 "),_("code",[e._v("Controller")]),e._v("，Controller 有多少可以复用的？我们写完了一个 Controller 之后，可以很方便地复用它吗？结论是：非常难复用。在某些场景下，我们可能可以用 "),_("code",[e._v("addSubViewController")]),e._v(" 之类的方式复用 Controller，但它的复用场景还是非常非常少的。")]),e._v(" "),_("p",[e._v("如果我们能够意识到 Controller 里面的代码不便于复用，我们就能知道什么代码应该写在 Controller 里面了，那就是那些不能复用的代码。在我看来，Controller 里面就只应该存放这些不能复用的代码，这些代码包括：")]),e._v(" "),_("ul",[_("li",[e._v("在初始化时，构造相应的 View 和 Model。")]),e._v(" "),_("li",[e._v("监听 Model 层的事件，将 Model 层的数据传递到 View 层。")]),e._v(" "),_("li",[e._v("监听 View 层的事件，并且将 View 层的事件转发到 Model 层。")])]),e._v(" "),_("p",[e._v("如果 Controller 只有以上的这些代码，那么它的逻辑将非常简单，而且也会非常短。")]),e._v(" "),_("p",[e._v("但是，我们却很难做到这一点，因为还是有很多逻辑我们不知道写在哪里，于是就都写到了 Controller 中了，那我们接下来就看看其它逻辑应该写在哪里。")]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"二-如何对-viewcontroller-瘦身？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二-如何对-viewcontroller-瘦身？"}},[e._v("#")]),e._v(" 二. 如何对 ViewController 瘦身？")]),e._v(" "),_("p",[e._v("objc.io 是一个非常有名的 iOS 开发博客，它上面的第一课 "),_("code",[e._v("《Lighter View Controllers》")]),e._v(" 上就讲了很多这样的技巧，我们先总结一下它里面的观点：")]),e._v(" "),_("ul",[_("li",[e._v("将 UITableView 的 Data Source 分离到另外一个类中。")]),e._v(" "),_("li",[e._v("将数据获取和转换的逻辑分别到另外一个类中。")]),e._v(" "),_("li",[e._v("将拼装控件的逻辑，分离到另外一个类中。")])]),e._v(" "),_("p",[e._v("你想明白了吗？其实 MVC 虽然只有三层，但是它并没有限制你只能有三层。所以，我们可以将 Controller 里面过于臃肿的逻辑抽取出来，形成新的可复用模块或架构层次。")]),e._v(" "),_("p",[e._v("我个人对于逻辑的抽取，有以下总结。")]),e._v(" "),_("h3",{attrs:{id:"_1-将网络请求抽象到单独的类中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-将网络请求抽象到单独的类中"}},[e._v("#")]),e._v(" 1. 将网络请求抽象到单独的类中")]),e._v(" "),_("p",[e._v("新手写代码，直接就在 Controller 里面用 "),_("code",[e._v("AFNetworking")]),e._v(" 发一个请求，请求的完数据直接就传递给 View。入门一些的同学，知道把这些请求代码移到另外一个静态类里面。但是我觉得还不够，所以我建议将每一个网络请求直接封装成类。")]),e._v(" "),_("p",[e._v("把每一个网络请求封装成对象其实是使用了设计模式中的 Command 模式，它有以下好处：")]),e._v(" "),_("ul",[_("li",[e._v("将网络请求与具体的第三方库依赖隔离，方便以后更换底层的网络库。实际上我们公司的 iOS 客户端最初是基于 ASIHttpRequest 的，我们只花了两天，就很轻松地切换到了 AFNetworking。")]),e._v(" "),_("li",[e._v("方便在基类中处理公共逻辑，例如猿题库的数据版本号信息就统一在基类中处理。")]),e._v(" "),_("li",[e._v("方便在基类中处理缓存逻辑，以及其它一些公共逻辑。")]),e._v(" "),_("li",[e._v("方便做对象的持久化。")])]),e._v(" "),_("p",[e._v("大家如果感兴趣，可以看我们公司开源的 iOS 网络库：YTKNetwork。它在这种思考的指导下，不但将 Controller 中的代码瘦身，而且进一步演化和加强，现在它还支持诸如复杂网络请求管理，断点续传，插件机制，JSON 合法性检查等功能。")]),e._v(" "),_("p",[e._v("这部分代码从 Controller 中剥离出来后，不但简化了 Controller 中的逻辑，也达到了网络层的代码复用的效果。")]),e._v(" "),_("h3",{attrs:{id:"_2-将界面的拼装抽象到专门的类中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-将界面的拼装抽象到专门的类中"}},[e._v("#")]),e._v(" 2. 将界面的拼装抽象到专门的类中")]),e._v(" "),_("p",[e._v("新手写代码，喜欢在 Controller 中把一个个 "),_("code",[e._v("UILabel")]),e._v(" ，"),_("code",[e._v("UIButton")]),e._v("，"),_("code",[e._v("UITextField")]),e._v(" 往 self.view 上用 "),_("code",[e._v("addSubView")]),e._v(" 方法放。我建议大家可以用两种办法把这些代码从 Controller 中剥离。")]),e._v(" "),_("p",[_("strong",[e._v("方法一：")])]),e._v(" "),_("p",[e._v("构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。")]),e._v(" "),_("p",[_("strong",[e._v("方法二：")])]),e._v(" "),_("p",[e._v("用一个静态的"),_("code",[e._v("Util")]),e._v(" 类，帮助你做 UIView 的拼装工作。这种方式稍微做得不太彻底，但是比较简单。")]),e._v(" "),_("p",[e._v("对于一些能复用的 UI 控件，我建议用方法一。如果项目工程比较复杂，我也建议用方法一。如果项目太紧，另外相关项目的代码量也不多，可以尝试方法二。")]),e._v(" "),_("h3",{attrs:{id:"_3-构造-viewmodel"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-构造-viewmodel"}},[e._v("#")]),e._v(" 3. 构造 ViewModel")]),e._v(" "),_("p",[e._v("谁说 MVC 就不能用 "),_("code",[e._v("ViewModel")]),e._v(" 的？MVVM 的优点我们一样可以借鉴。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。")]),e._v(" "),_("p",[e._v("这样抽象之后，View 只接受 ViewModel，而 Controller 只需要传递 ViewModel 这么一行代码。而另外构造 ViewModel 的过程，我们就可以移动到另外的类中了。")]),e._v(" "),_("p",[e._v("在具体实践中，我建议大家专门创建构造 ViewModel 工厂类，参见 工厂模式。另外，也可以专门将数据存取都抽将到一个 Service 层，由这层来提供 ViewModel 的获取。")]),e._v(" "),_("h3",{attrs:{id:"_4-专门构造存储类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-专门构造存储类"}},[e._v("#")]),e._v(" 4. 专门构造存储类")]),e._v(" "),_("p",[e._v("刚刚说到 ViewModel 的构造可以抽奖到一个 Service 层。与此相应的，数据的存储也应该由专门的对象来做。在小猿搜题项目中，我们由一个叫 UserAgent 的类，专门来处理本地数据的存取。")]),e._v(" "),_("p",[e._v("数据存取放在专门的类中，就可以针对存取做额外的事情了。比如：")]),e._v(" "),_("ul",[_("li",[e._v("对一些热点数据增加缓存")]),e._v(" "),_("li",[e._v("处理数据迁移相关的逻辑")])]),e._v(" "),_("p",[e._v("如果要做得更细，可以把存储引擎再抽象出一层。这样你就可以方便地切换存储的底层，例如从 sqlite 切换到 key-value 的存储引擎等。")]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"三-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三-总结"}},[e._v("#")]),e._v(" 三. 总结")]),e._v(" "),_("p",[e._v("通过代码的抽取，我们可以将原本的 MVC 设计模式中的 "),_("code",[e._v("ViewController")]),e._v(" 进一步拆分，构造出 "),_("code",[e._v("网络请求层")]),e._v("、"),_("code",[e._v("ViewModel 层")]),e._v("、"),_("code",[e._v("Service 层")]),e._v("、"),_("code",[e._v("Storage 层")]),e._v("等其它类，来配合 Controller 工作，从而使 Controller 更加简单，我们的 App 更容易维护。")]),e._v(" "),_("p",[e._v("另外，不知道大家注意到没，其实 Controller 层是非常难于测试的，如果我们能够将 Controller 瘦身，就可以更方便地写 Unit Test 来测试各种与界面的无关的逻辑。移动端自动化测试框架都不太成熟，但是将 Controller 的代码抽取出来，是有助于我们做测试工作的。")]),e._v(" "),_("p",[e._v("希望本文能帮助大家掌握正确使用 MVC 的姿势。")]),e._v(" "),_("br")])}),[],!1,null,null,null);v.default=l.exports}}]);